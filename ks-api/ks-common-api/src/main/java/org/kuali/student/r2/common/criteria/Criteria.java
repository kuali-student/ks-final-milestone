/**
 * Copyright 2005-2014 The Kuali Foundation
 *
 * Licensed under the Educational Community License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.opensource.org/licenses/ecl2.php
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.kuali.student.r2.common.criteria;

import org.kuali.rice.core.api.util.Truth;
import org.kuali.rice.core.api.util.type.TypeUtils;

import javax.persistence.Query;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;

/**
 * A criteria builder for JPQL Query objects.
 *
 * <p>All entities in queries generated by this class will be given an alias, and an initial entity (with an initial alias)
 * is mandatory. If no alias is given or if a constructor without an alias parameter is used, a new alias name will be
 * auto-generated.
 *
 * <p>The interpretation of the initial entity depends on what type of query is intended. If a SELECT query is desired,
 * the initial entity will be the first to appear in the FROM clause. If a DELETE query is desired, the initial
 * entity will be the one that appears in the DELETE FROM clause. If an UPDATE query is desired, the initial entity
 * will be the one that appears in the UPDATE clause. 
 *
 * <p>Most of the methods of this class rely on String expressions representing entity properties, or functions
 * acting on constants or entity properties. If the expression contains functions or if
 * you wish to reference the property of an entity other than the first aliased entity of the query, then the
 * String expression must include the alias of the entity in the format __JPA_ALIAS[[index]]__ or the format
 * __JPA_ALIAS[['alias']]__ , where "index" is a numeric index pointing to the Nth alias of the current query in the
 * order that the aliases were added to the query (starting at zero), and where "'alias'" is the String name of the
 * entity alias enclosed in single quotes.
 *
 * <p>If the String expression as defined above does not contain custom JPA aliases, then the initial alias of the current
 * Criteria (and a '.' to separate the alias from the expression) will be prepended to the expression automatically.
 *
 * <p>If the current Criteria is intended for use as a sub-query, then aliases of the parent Criteria can be referred to
 * by name (so long as they do not conflict with the alias names in the sub-Criteria) or by specifying the bitwise NOT of
 * the alias index in the parent Criteria (-1 for 0, -2 for 1, etc.). When including a sub-query in a parent query, the
 * parent Criteria will handle the updating of the alias indexes and will auto-generate new aliases as needed if any of
 * the sub-query's defined aliases are duplicates of those in the parent query.
 *
 * <p>For Criteria objects intended to be ANDed or ORed with an existing Criteria, it is assumed that any named or indexed
 * aliases refer to exactly the same aliases as in the existing Criteria. Any auto-prepended aliases as described above
 * will always be referred to by index, so it is safe for them to be included in the Criteria to be ANDed/ORed with the
 * existing one. Both of these details also apply when adding new Criteria to the HAVING clause of an existing Criteria, or
 * when inserting the negation of another Criteria's conditions into an existing Criteria as a "NOT (...)" expression.
 *
 * <p>Also, during query construction, the Criteria API will automatically include substrings in the format
 * __JPA_PARAM[['parameter']]__ when adding input parameters, where 'parameter' is the auto-generated name of the
 * parameter. Care should be taken to ensure that __JPA_ALIAS[[...]]__ and __JPA_PARAM[[...]]__ expressions are not
 * being added to queries that wish to interpret such String patterns literally.
 *
 * <p>Note that Criteria instances are not thread-safe, so external synchronization is necessary if operating on them
 * from multiple threads.
 *
 * <p>
 *
 * @author Kuali Rice Team (rice.collab@kuali.org)
 */

//TODO: KSENROLL-11915 this file was duplicated from rice. remove this and fix AttributeTransform
@SuppressWarnings("unchecked")
@Deprecated
public class Criteria {

    private static final org.apache.log4j.Logger LOG = org.apache.log4j.Logger.getLogger(Criteria.class);
    private static final Pattern APOS_PAT = Pattern.compile("'");
    private static final String[] LOOKUP_WILDCARDS = {"*", "?"};
    private static final String[] ESCAPED_LOOKUP_WILDCARDS = {"\\*", "\\?"};
    private static final char[] JPQL_WILDCARDS = {'%', '_'};

    /** The String representing the beginning of a by-name or by-index reference to an entity alias. */
    public static final String JPA_ALIAS_PREFIX = "__JPA_ALIAS[[";
    /** The String representing the beginning of a by-name reference to an input parameter. */
    public static final String JPA_PARAM_PREFIX = "__JPA_PARAM[[";
    /** The String representing the termination of by-name/index references to aliases or input parameters. */
    public static final String JPA_ALIAS_SUFFIX = "]]__";

    private static final String JPA_INITIAL_ALIAS = JPA_ALIAS_PREFIX + "0" + JPA_ALIAS_SUFFIX;
    private static final String JPA_PARENT_INITIAL_ALIAS = JPA_ALIAS_PREFIX + "-1" + JPA_ALIAS_SUFFIX;

    private static final String JPA_PARAM_PREFIX_WITH_COLON = ":" + JPA_PARAM_PREFIX;
    private static final int ALIAS_PREFIX_LEN = JPA_ALIAS_PREFIX.length();
    private static final int PARAM_PREFIX_LEN = JPA_PARAM_PREFIX.length();
    private static final int ALIAS_SUFFIX_LEN = JPA_ALIAS_SUFFIX.length();

    private Integer searchLimit;

    private int generatedAliasCount;

    private int generatedBindParamCount;

    private boolean distinct = false;

    private final List<String> entityAliases = new ArrayList<String>();

    private final List<String> indexedAliasPlaceholders = new ArrayList<String>();

    private final List<String> namedAliasPlaceholders = new ArrayList<String>();

    private final Map<String,Integer> aliasIndexes = new HashMap<String,Integer>();

    private final StringBuilder selectClause = new StringBuilder();

    private final StringBuilder fromClause = new StringBuilder();

    private final StringBuilder whereClause = new StringBuilder(50);

    private final StringBuilder groupByClause = new StringBuilder();

    private final StringBuilder havingClause = new StringBuilder();

    private final StringBuilder orderByClause = new StringBuilder();

    private final StringBuilder setClause = new StringBuilder();

    private final String initialEntityName;

    protected Map<String, Object> params = new LinkedHashMap<String, Object>();

    /**
     * Constructs a new Criteria instance that includes the given initial entity. An alias will be
     * auto-generated for this entity, and the entity's alias will be included in the SELECT clause if this
     * Criteria is intended to be used as a SELECT query.
     *
     * @param entityName The class name of the initial JPA entity.
     */
    public Criteria(String entityName) {
        this(entityName, "a", true);
    }

    /**
     * Constructs a new Criteria instance that includes the given initial entity. The given alias
     * will be used for this entity if it is non-null, and the alias will be included in the SELECT clause
     * if this Criteria is intended to be used as a SELECT query.
     *
     * @param entityName The class name of the initial JPA entity.
     * @param alias The alias to use for this entity; if it is null, a new alias will be auto-generated.
     */
    public Criteria(String entityName, String alias) {
        this(entityName, alias, true);
    }

    /**
     * Constructs a new Criteria instance that includes the given initial entity. An alias will be
     * auto-generated for this entity, and the extra parameter indicates whether this alias should also be
     * added to the query's SELECT clause (if this Criteria is intended to be used as a SELECT query).
     *
     * @param entityName The class name of the initial JPA entity.
     * @param includeEntityInSelect Indicates whether this entity's alias should be added to the SELECT clause.
     */
    public Criteria(String entityName, boolean includeEntityInSelect) {
        this(entityName, "a", includeEntityInSelect);
    }

    /**
     * Constructs a new Criteria instance that includes the given initial entity. The given alias
     * will be used for this entity if it is non-null, and the extra parameter indicates whether the alias
     * should be added to the SELECT clause (if this Criteria is intended to be used as a SELECT query).
     *
     * @param entityName The class name of the initial JPA entity.
     * @param alias The alias to use for this entity; if it is null, a new alias will be auto-generated.
     * @param includeEntityAliasInSelect Indicates whether this entity's alias should be added to the SELECT clause.
     */
    public Criteria(String entityName, String alias, boolean includeEntityAliasInSelect) {
        this.initialEntityName = entityName;
        from(entityName, alias, includeEntityAliasInSelect);
    }

    /*
     * Adds the given alias to the Criteria's alias lists/maps. If the alias is null or it duplicates an
     * existing one, a new alias will be auto-generated.
     *
     * Returns the new name of the alias, or the passed-in name if non-null and no conflicts were found.
     */
    private String addAlias(String alias) {
        if (alias == null) {
            alias = "a" + (generatedAliasCount++);
        }
        while (aliasIndexes.containsKey(alias)) {
            alias = "a" + (generatedAliasCount++);
        }
        entityAliases.add(alias);
        aliasIndexes.put(alias, entityAliases.size() - 1);
        indexedAliasPlaceholders.add(new StringBuilder(30).append(JPA_ALIAS_PREFIX).append(indexedAliasPlaceholders.size()).append(JPA_ALIAS_SUFFIX).toString());
        namedAliasPlaceholders.add(new StringBuilder(30).append(JPA_ALIAS_PREFIX).append('\'').append(alias).append('\'').append(JPA_ALIAS_SUFFIX).toString());
        return alias;
    }

    /**
     * Adds the given expression to the SELECT clause. If no properly-referenced alias appears
     * in the String expression, it will be assumed that the expression is accessing something
     * on or through the initial entity. See the description of this class for more information
     * on how String expressions are interpreted.
     *
     * @param resultExpression The String expression to add to the SELECT clause.
     */
    public void select(String resultExpression) {
        if (resultExpression.contains(JPA_ALIAS_PREFIX)) {
            selectClause.append((selectClause.length() > 0) ? ", " : "").append(resultExpression);
        } else {
            selectClause.append((selectClause.length() > 0) ? ", " : "").append(JPA_INITIAL_ALIAS).append('.').append(resultExpression);
        }
    }

    /**
     * Adds a new JPA entity to the FROM clause. The entity will be given the provided alias if it
     * is non-null and does not conflict with any existing alias names; otherwise, a new alias name
     * will be auto-generated. An extra parameter is also included for indicating whether this
     * Criteria should automatically include the entity's alias in the SELECT clause.
     *
     * @param entityName The class name of the new entity.
     * @param alias The alias to use for this entity.
     * @param includeEntityAliasInSelect Indicates whether to include the entity's alias in the SELECT clause.
     * @return The provided alias if it's non-null and does not conflict with any existing names, or an auto-generated alias name otherwise.
     */
    public String from(String entityName, String alias, boolean includeEntityAliasInSelect) {
        alias = addAlias(alias);
        if (includeEntityAliasInSelect) {
            select(namedAliasPlaceholders.get(namedAliasPlaceholders.size() - 1));
        }
        fromClause.append((fromClause.length() > 0) ? ", " : " FROM ").append(entityName).append(" AS ").append(
                namedAliasPlaceholders.get(namedAliasPlaceholders.size() - 1));
        return alias;
    }

    /**
     * Adds a new "IN (...)" expression containing the given collection expression into the FROM clause.
     * The collection will be given the provided alias if it is non-null and does not conflict with
     * any existing alias names; otherwise, a new alias name will be auto-generated. An extra parameter
     * is also included for indicating whether this Criteria should automatically include the
     * collection's alias in the SELECT clause.
     *
     * <p>If no properly-referenced alias appears in the String expression, it will be assumed that the
     * expression points to a collection that is accessible on or through the initial entity. See the
     * description of this class for more information on how String expressions are interpreted.
     *
     * @param collectionName A String expression that points to an entity collection.
     * @param alias The alias to use for this collection expression.
     * @param includeCollectionAliasInSelect Indicates whether to include the collection's alias in the SELECT clause.
     * @return The provided alias if it's non-null and does not conflict with any existing names, or an auto-generated alias name otherwise.
     */
    public String fromIn(String collectionName, String alias, boolean includeCollectionAliasInSelect) {
        alias = addAlias(alias);
        if (includeCollectionAliasInSelect) {
            select(namedAliasPlaceholders.get(namedAliasPlaceholders.size() - 1));
        }
        // The optional "AS" keyword is excluded when creating the "IN (...)" expression because Hibernate will throw an exception if it exists.
        if (collectionName.contains(JPA_ALIAS_PREFIX)) {
            fromClause.append(", IN (").append(collectionName).append(") ").append(namedAliasPlaceholders.get(namedAliasPlaceholders.size() - 1));
        } else {
            fromClause.append(", IN (").append(JPA_INITIAL_ALIAS).append('.').append(collectionName).append(") ").append(
                    namedAliasPlaceholders.get(namedAliasPlaceholders.size() - 1));
        }
        return alias;
    }

    /**
     * Adds a new JOIN to the most-recently-added entity in the FROM clause. The association
     * will be given the provided alias if it is non-null and does not conflict with
     * any existing alias names; otherwise, a new alias name will be auto-generated. An extra parameter
     * is also included for indicating whether this Criteria should automatically include the
     * association's alias in the SELECT clause.
     *
     * <p>If no properly-referenced alias appears in the String expression, it will be assumed that the
     * expression points to an association that is accessible on or through the initial entity. See the
     * description of this class for more information on how String expressions are interpreted.
     *
     * @param associationName A String expression that points to an entity association.
     * @param alias The alias to use for this association expression.
     * @param includeAssociationAliasInSelect Indicates whether to include the collection's alias in the SELECT clause.
     * @param innerJoin If true, the join will be an inner join; otherwise, it will be a left (outer) join.
     * @return The provided alias if it's non-null and does not conflict with any existing names, or an auto-generated alias name otherwise.
     */
    public String join(String associationName, String alias, boolean includeAssociationAliasInSelect, boolean innerJoin) {
        alias = addAlias(alias);
        if (includeAssociationAliasInSelect) {
            select(namedAliasPlaceholders.get(namedAliasPlaceholders.size() - 1));
        }
        if (associationName.contains(JPA_ALIAS_PREFIX)) {
            fromClause.append(innerJoin ? " INNER JOIN " : " LEFT JOIN ").append(associationName).append(" AS ").append(
                    namedAliasPlaceholders.get(namedAliasPlaceholders.size() - 1));
        } else {
            fromClause.append(innerJoin ? " INNER JOIN " : " LEFT JOIN ").append(JPA_INITIAL_ALIAS).append('.').append(
                    associationName).append(" AS ").append(namedAliasPlaceholders.get(namedAliasPlaceholders.size() - 1));
        }
        return alias;
    }

    /**
     * Adds a new JOIN FETCH to the most-recently-added entity in the FROM clause. If no
     * properly-referenced alias appears in the String expression, it will be assumed that the
     * expression points to an association that is accessible on or through the initial entity. See the
     * description of this class for more information on how String expressions are interpreted.
     *
     * @param associationName A String expression that points to an entity association.
     * @param innerJoin If true, the join will be an inner join; otherwise, it will be a left (outer) join.
     */
    public void joinFetch(String associationName, boolean innerJoin) {
        if (associationName.contains(JPA_ALIAS_PREFIX)) {
            fromClause.append(innerJoin ? " INNER JOIN FETCH " : " LEFT JOIN FETCH ").append(associationName);
        } else {
            fromClause.append(innerJoin ? " INNER JOIN FETCH " : " LEFT JOIN FETCH ").append(JPA_INITIAL_ALIAS).append('.').append(associationName);
        }
    }

    /**
     * Adds a new attribute assignment expression to the SET clause (for use with UPDATE queries). It is
     * assumed that the given attribute belongs to the initial entity, so a custom alias should not be used.
     *
     * @param attributeName An expression pointing to an attribute that is accessible on or through the initial entity.
     * @param value The value to assign to the attribute.
     */
    public void set(String attributeName, Object value) {
        setClause.append((setClause.length() > 0) ? ", " : " SET ").append(JPA_INITIAL_ALIAS).append('.').append(attributeName).append(
                " = ").append(addAttr(fixPeriods(attributeName), value));
    }

    /**
     * Adds one new attribute assignment expression to the SET clause for each entry in the given Map (for use with
     * UPDATE queries). It is assumed that the attributes belong to the initial entity, so custom aliases should not be used.
     *
     * @param attributes A Map containing expressions pointing to initial-entity-accessible attributes and their associated values.
     */
    public void set(Map<String,Object> attributes) {
        for (Map.Entry<String,Object> attribute : attributes.entrySet()) {
            setClause.append((setClause.length() > 0) ? ", " : " SET ").append(JPA_INITIAL_ALIAS).append('.').append(attribute.getKey()).append(
                    " = ").append(addAttr(fixPeriods(attribute.getKey()), attribute.getValue()));
        }
    }

    /*
     * Converts an Object into a JPQL-valid constant, or creates a new input parameter for it, depending on the Object type.
     * Booleans are converted to "true" or "false", numbers are converted to their String representations, Strings are
     * surrounded in single quotes and their existing single quotes are doubled, Class objects are converted to their
     * getName() values and are left unquoted, null values are ignored, and all other Objects are assigned to an input
     * parameter. The fixed constant or parameter name will be appended to the end of the given StringBuilder.
     */
    private void fixValue(StringBuilder queryClause, Object value) {
        if (value == null) { return; }
        Class<?> propertyType = value.getClass();
        if(TypeUtils.isIntegralClass(propertyType) || TypeUtils.isDecimalClass(propertyType)) {
            queryClause.append(value.toString());
        } else if (TypeUtils.isStringClass(propertyType)) {
            queryClause.append('\'').append(fixSingleQuotes(value.toString())).append('\'');
        } else if (TypeUtils.isBooleanClass(propertyType)) {
            queryClause.append(value.toString());
        } else if (value instanceof Class) {
            queryClause.append(((Class)value).getName());
        } else {
            queryClause.append(addAttr("bind_param" + (++generatedBindParamCount), value));
        }
    }

    /*
     * Fixes the single quotes of the given String by doubling them. Note that this method
     * will *not* wrap the final value in single quotes.
     */
    private String fixSingleQuotes(String value) {
        return APOS_PAT.matcher(value).replaceAll("''");
    }

    /*
     * Fixes the periods of the given String by converting them to underscores.
     */
    private String fixPeriods(String value) {
        return value.replace('.', '_');
    }

    /*
     * Fixes the search pattern by converting all non-escaped lookup wildcards ("*" and "?") into their
     * respective JPQL wildcards ("%" and "_"). Any lookup wildcards escaped by a backslash are converted
     * into their non-backslashed equivalents.
     */
    private String fixSearchPattern(String value) {
        StringBuilder fixedPattern = new StringBuilder(value);
        int valueLen = value.length();
        String lookupWildcard;
        String escapedLookupWildcard;
        char jpqlWildcard;
        // Convert all non-escaped  wildcards.
        for (int i = 0; i < LOOKUP_WILDCARDS.length; i++) {
            lookupWildcard = LOOKUP_WILDCARDS[i];
            escapedLookupWildcard = ESCAPED_LOOKUP_WILDCARDS[i];
            jpqlWildcard = JPQL_WILDCARDS[i];
            int wildcardIndex = fixedPattern.indexOf(lookupWildcard);
            int escapedWildcardIndex = fixedPattern.indexOf(escapedLookupWildcard);
            while (wildcardIndex != -1) {
                if (wildcardIndex == 0 || escapedWildcardIndex != wildcardIndex - 1) {
                    fixedPattern.setCharAt(wildcardIndex, jpqlWildcard);
                    wildcardIndex = fixedPattern.indexOf(lookupWildcard, wildcardIndex);
                } else {
                    fixedPattern.replace(escapedWildcardIndex, wildcardIndex + 1, lookupWildcard);
                    wildcardIndex = fixedPattern.indexOf(lookupWildcard, wildcardIndex);
                    escapedWildcardIndex = fixedPattern.indexOf(escapedLookupWildcard, wildcardIndex);
                }
            }
        }
        return fixedPattern.toString();
    }

    /*
     * Automatically appends a new " AND " to the WHERE clause if adding more than one condition to it,
     * and also appends the initial entity's alias and a '.' if the expression does not contain any
     * properly-referenced aliases (as defined in the description of this class).
     */
    private void preparePrefixIfNecessary(String attribute) {
        whereClause.append((whereClause.length() > 0) ? " AND " : "");
        if (!attribute.contains(JPA_ALIAS_PREFIX)) {
            whereClause.append(JPA_INITIAL_ALIAS).append('.');
        }
    }

    /*
     * Generates a new input parameter name and associates it with the given value, or (if the value
     * is a Class object) just returns the value's getName() String w/out adding it to a parameter. The
     * parameter's name will resemble the "attribute" String with the periods converted to
     * underscores, unless such a parameter already exists or "attribute" contains a properly-referenced
     * alias (in which case a new unique name will be auto-generated).
     * Returns the finalized input parameter name as a "__JPA_PARAM[['...']]__" String (with a ":" prefix)
     * if the value is not a Class; otherwise, returns the getName() String of the Class object.
     */
    private String prepareAttribute(String attribute, Object value) {
        return ( value instanceof Class ? ((Class)value).getName() :
                ( attribute.contains(JPA_ALIAS_PREFIX) ? addAttr("bind_param" + (++generatedBindParamCount), value) : addAttr(fixPeriods(attribute), value) ) );
    }

    /*
     * Generates new input parameter names using "attribute" as a base, and associates each new
     * parameter with the corresponding provided value (unless the given value is a Class object,
     * in which case the Class's getName() String will be used w/out adding it to a parameter).
     * The parameters' names will resemble the "attribute" String (with the periods converted to
     * underscores) plus the suffix "_bN" (where N is the index of the value associated with the
     * parameter), unless such parameters already exist or "attribute" contains a
     * properly-referenced alias (in which case new unique names will be auto-generated).
     * Returns an array of parameter names as "__JPA_PARAM[['...']]__" Strings (with ":" prefixes),
     * where each name corresponds to the associated value at the same index, and where the returned
     * array has a length equal to the number of provided values (but note that if a given value is a
     * Class object, its getName() String will be returned at that index instead and no input
     * parameter will be added for it).
     */
    private String[] prepareAttributes(String attribute, Object... values) {
        int count = values.length;
        String[] fixedAttrs = new String[count];
        if (attribute.contains(JPA_ALIAS_PREFIX)) {
            int tempParamCount = ++generatedBindParamCount;
            for (int i = 0; i < count; i++) {
                fixedAttrs[i] = (values[i] instanceof Class) ? ((Class)values[i]).getName() :
                        addAttr(new StringBuilder(20).append("bind_param").append(tempParamCount).append("_b").append(i + 1).toString(), values[i]);
            }
        } else {
            attribute = fixPeriods(attribute);
            for (int i = 0; i < count; i++) {
                fixedAttrs[i] = (values[i] instanceof Class) ? ((Class)values[i]).getName() :
                        addAttr(new StringBuilder(attribute.length() + 5).append(attribute).append("_b").append(i + 1).toString(), values[i]);
            }
        }
        return fixedAttrs;
    }

    /*
     * Automatically appends a new " AND " to the WHERE clause if adding more than one condition to it,
     * and also appends the initial entity's alias and a '.' if the expression does not contain any
     * properly-referenced aliases (as defined in the description of this class). In addition, a new
     * input parameter name is generated, and the parameter will be associated with the given value (unless
     * the object is a Class object, in which case its getName() value will be used instead and no input
     * parameter will be created for it). The parameter's name will resemble the "attribute" String with
     * the periods converted to underscores, unless such a parameter already exists or "attribute" contains
     * a properly-referenced alias (in which case a new unique name will be auto-generated).
     * Returns the finalized input parameter name as a "__JPA_PARAM[['...']]__" String (with a ":" prefix)
     * if it is not a Class object; otherwise, its getName() String will be returned instead.
     */
    private String preparePrefixAndAttributeIfNecessary(String attribute, Object value) {
        whereClause.append((whereClause.length() > 0) ? " AND " : "");
        if (value instanceof Class) {
            return ((Class)value).getName();
        } else if (attribute.contains(JPA_ALIAS_PREFIX)) {
            return addAttr("bind_param" + (++generatedBindParamCount), value);
        } else {
            whereClause.append(JPA_INITIAL_ALIAS).append('.');
            return addAttr(fixPeriods(attribute), value);
        }
    }

    /*
     * Adds a new input parameter and its value to the parameter Map, auto-generating a new key if the provided one already exists.
     * Returns the finalized key as a "__JPA_PARAM[['...']]__" String with a prepended ":".
     */
    private String addAttr(String string, Object value) {
        while (params.containsKey(string)) {
            string = "bind_param" + (++generatedBindParamCount);
        }
        params.put(string, value);
        return new StringBuilder(45).append(JPA_PARAM_PREFIX_WITH_COLON).append('\'').append(string).append('\'').append(JPA_ALIAS_SUFFIX).toString();
    }

    /**
     * Adds a new BETWEEN condition to the WHERE clause, ANDing it with any existing conditions if necessary.
     *
     * @param attribute An expression representing the subject of the BETWEEN condition.
     * @param value1 The lower value of the BETWEEN condition.
     * @param value2 The upper value of the BETWEEN condition.
     */
    public void between(String attribute, Object value1, Object value2) {
        preparePrefixIfNecessary(attribute);
        String[] fixedAttrs = prepareAttributes(attribute, value1, value2);
        whereClause.append(attribute).append(" BETWEEN ").append(fixedAttrs[0]).append(" AND ").append(fixedAttrs[1]);
    }

    /**
     * Adds a new NOT BETWEEN condition to the WHERE clause, ANDing it with any existing conditions if necessary.
     *
     * @param attribute An expression representing the subject of the NOT BETWEEN condition.
     * @param value1 The lower value of the NOT BETWEEN condition.
     * @param value2 The upper value of the NOT BETWEEN condition.
     */
    public void notBetween(String attribute, Object value1, Object value2) {
        preparePrefixIfNecessary(attribute);
        String[] fixedAttrs = prepareAttributes(attribute, value1, value2);
        whereClause.append(attribute).append(" NOT BETWEEN ").append(fixedAttrs[0]).append(" AND ").append(fixedAttrs[1]);
    }

    /**
     * Adds an equality condition to the WHERE clause, ANDing it with any existing conditions if necessary.
     *
     * @param attribute An expression representing the left-hand side of this condition.
     * @param value The value to check for equality with.
     */
    public void eq(String attribute, Object value) {
        String fixedAttr = preparePrefixAndAttributeIfNecessary(attribute, value);
        whereClause.append(attribute).append(" = ").append(fixedAttr);
    }

    /**
     * Adds a greater-than condition to the WHERE clause, ANDing it with any existing conditions if necessary.
     *
     * @param attribute An expression representing the left-hand side of this condition.
     * @param value The value on the right-hand side of the greater-than condition.
     */
    public void gt(String attribute, Object value) {
        String fixedAttr = preparePrefixAndAttributeIfNecessary(attribute, value);
        whereClause.append(attribute).append(" > ").append(fixedAttr);
    }

    /**
     * Adds a greater-than-or-equal condition to the WHERE clause, ANDing it with any existing conditions if necessary.
     *
     * @param attribute An expression representing the left-hand side of this condition.
     * @param value The value on the right-hand side of the greater-than-or-equal condition.
     */
    public void gte(String attribute, Object value) {
        String fixedAttr = preparePrefixAndAttributeIfNecessary(attribute, value);
        whereClause.append(attribute).append(" >= ").append(fixedAttr);
    }

    /**
     * Adds a new LIKE condition to the WHERE clause, ANDing it with any existing conditions if necessary.
     * If the provided value is not a String, its toString() representation will be used as the pattern.
     *
     * @param attribute An expression representing the left-hand side of this condition.
     * @param value The pattern to compare with for "likeness".
     */
    public void like(String attribute, Object value) {
        String fixedAttr = preparePrefixAndAttributeIfNecessary(attribute, fixSearchPattern(value.toString()));
        whereClause.append(attribute).append(" LIKE ").append(fixedAttr);
    }

    /**
     * Adds a new NOT LIKE condition to the WHERE clause, ANDing it with any existing conditions if necessary.
     * If the provided value is not a String, its toString() representation will be used as the pattern.
     *
     * @param attribute An expression representing the left-hand side of this condition.
     * @param value The pattern to compare with for "non-likeness".
     */
    public void notLike(String attribute, Object value) {
        String fixedAttr = preparePrefixAndAttributeIfNecessary(attribute, fixSearchPattern(value.toString()));
        whereClause.append(attribute).append(" NOT LIKE ").append(fixedAttr);
    }

    /**
     * Adds a new LIKE condition (containing an ESCAPE clause) to the WHERE clause, ANDing it with any
     * existing conditions if necessary.
     * If the provided value is not a String, its toString() representation will be used as the pattern.
     *
     * @param attribute An expression representing the left-hand side of this condition.
     * @param value The pattern to compare with for "likeness".
     * @param escapeChar The designated wildcard escape character for the given value.
     */
    public void likeEscape(String attribute, Object value, char escapeChar) {
        String fixedAttr = preparePrefixAndAttributeIfNecessary(attribute, fixSearchPattern(value.toString()));
        whereClause.append(attribute).append(" LIKE ").append(fixedAttr).append(" ESCAPE ").append(
                prepareAttribute(JPA_ALIAS_PREFIX, Character.valueOf(escapeChar)));
    }

    /**
     * Adds a new NOT LIKE condition (containing an ESCAPE clause) to the WHERE clause, ANDing it with any
     * existing conditions if necessary.
     * If the provided value is not a String, its toString() representation will be used as the pattern.
     *
     * @param attribute An expression representing the left-hand side of this condition.
     * @param value The pattern to compare with for "non-likeness".
     * @param escapeChar The designated wildcard escape character for the given value.
     */
    public void notLikeEscape(String attribute, Object value, char escapeChar) {
        String fixedAttr = preparePrefixAndAttributeIfNecessary(attribute, fixSearchPattern(value.toString()));
        whereClause.append(attribute).append(" NOT LIKE ").append(fixedAttr).append(" ESCAPE ").append(
                prepareAttribute(JPA_ALIAS_PREFIX, Character.valueOf(escapeChar)));
    }

    /**
     * Adds a less-than condition to the WHERE clause, ANDing it with any existing conditions if necessary.
     *
     * @param attribute An expression representing the left-hand side of this condition.
     * @param value The value on the right-hand side of the less-than condition.
     */
    public void lt(String attribute, Object value) {
        String fixedAttr = preparePrefixAndAttributeIfNecessary(attribute, value);
        whereClause.append(attribute).append(" < ").append(fixedAttr);
    }

    /**
     * Adds a less-than-or-equal condition to the WHERE clause, ANDing it with any existing conditions if necessary.
     *
     * @param attribute An expression representing the left-hand side of this condition.
     * @param value The value on the right-hand side of the less-than-or-equal condition.
     */
    public void lte(String attribute, Object value) {
        String fixedAttr = preparePrefixAndAttributeIfNecessary(attribute, value);
        whereClause.append(attribute).append(" <= ").append(fixedAttr);
    }

    /**
     * Adds a non-equality condition to the WHERE clause, ANDing it with any existing conditions if necessary.
     *
     * @param attribute An expression representing the left-hand side of this condition.
     * @param value The value on the right-hand side of the non-equality condition.
     */
    public void ne(String attribute, Object value) {
        String fixedAttr = preparePrefixAndAttributeIfNecessary(attribute, value);
        whereClause.append(attribute).append(" <> ").append(fixedAttr);
    }

    /**
     * Adds an IS NULL condition to the WHERE clause, ANDing it with any existing conditions if necessary.
     *
     * @param attribute An expression representing what needs the null check.
     */
    public void isNull(String attribute) {
        preparePrefixIfNecessary(attribute);
        whereClause.append(attribute).append(" IS NULL");
    }

    /**
     * Adds an IS NOT NULL condition to the WHERE clause, ANDing it with any existing conditions if necessary.
     *
     * @param attribute An expression representing what needs the not-null check.
     */
    public void notNull(String attribute) {
        preparePrefixIfNecessary(attribute);
        whereClause.append(attribute).append(" IS NOT NULL");
    }

    /**
     * Adds a MEMBER OF condition to the WHERE clause, ANDing it with any existing conditions if necessary.
     * Uses an input parameter for the single-value part of the condition.
     *
     * @param value An Object that may or may not be in the specified collection.
     * @param collection An expression representing a collection.
     */
    public void memberOf(Object value, String collection) {
        String fixedAttr = prepareAttribute(collection, value);
        preparePrefixIfNecessary(JPA_ALIAS_PREFIX);
        whereClause.append(fixedAttr).append(" MEMBER OF ").append(
                collection.contains(JPA_ALIAS_PREFIX) ? "" : JPA_INITIAL_ALIAS + ".").append(collection);
    }

    /**
     * Adds a MEMBER OF condition to the WHERE clause, ANDing it with any existing conditions if necessary.
     * Uses an expression for the single-value part of the condition.
     *
     * @param attribute An expression pointing to an attribute that may or may not be in the given collection.
     * @param collection An expression representing a collection.
     */
    public void memberOf(String attribute, String collection) {
        preparePrefixIfNecessary(attribute);
        whereClause.append(attribute).append(" MEMBER OF ").append(
                collection.contains(JPA_ALIAS_PREFIX) ? "" : JPA_INITIAL_ALIAS + ".").append(collection);
    }

    /**
     * Adds a NOT MEMBER OF condition to the WHERE clause, ANDing it with any existing conditions if necessary.
     * Uses an input parameter for the single-value part of the condition.
     *
     * @param value An Object that may or may not be in the specified collection.
     * @param collection An expression representing a collection.
     */
    public void notMemberOf(Object value, String collection) {
        String fixedAttr = prepareAttribute(collection, value);
        preparePrefixIfNecessary(JPA_ALIAS_PREFIX);
        whereClause.append(fixedAttr).append(" NOT MEMBER OF ").append(
                collection.contains(JPA_ALIAS_PREFIX) ? "" : JPA_INITIAL_ALIAS + ".").append(collection);
    }

    /**
     * Adds a NOT MEMBER OF condition to the WHERE clause, ANDing it with any existing conditions if necessary.
     * Uses an expression for the single-value part of the condition.
     *
     * @param attribute An expression pointing to an attribute that may or may not be in the given collection.
     * @param collection An expression representing a collection.
     */
    public void notMemberOf(String attribute, String collection) {
        preparePrefixIfNecessary(attribute);
        whereClause.append(attribute).append(" NOT MEMBER OF ").append(
                collection.contains(JPA_ALIAS_PREFIX) ? "" : JPA_INITIAL_ALIAS + ".").append(collection);
    }

    /**
     * Adds an IS EMPTY condition to the WHERE clause, ANDing it with any existing conditions if necessary.
     *
     * @param collection An expression representing a collection.
     */
    public void isEmpty(String collection) {
        preparePrefixIfNecessary(collection);
        whereClause.append(collection).append(" IS EMPTY");
    }

    /**
     * Adds an IS NOT EMPTY condition to the WHERE clause, ANDing it with any existing conditions if necessary.
     *
     * @param collection An expression representing a collection.
     */
    public void notEmpty(String collection) {
        preparePrefixIfNecessary(collection);
        whereClause.append(collection).append(" IS NOT EMPTY");
    }

    /**
     * Converts the given Criteria into a sub-SELECT query, surrounds it in parentheses, and adds a new
     * "IN (...)" condition containing the resulting expression into the WHERE clause, while ANDing
     * the new condition with any existing conditions if necessary.
     *
     * @param attribute An expression representing the left-hand side of the "IN (...)" condition.
     * @param in The Criteria representing the sub-query of the "IN (...)" condition.
     */
    public void in(String attribute, Criteria in) {
        if (in == null) { throw new IllegalArgumentException("'IN' Criteria cannot be null"); }
        preparePrefixIfNecessary(attribute);
        whereClause.append(attribute).append(" IN ");
        subQuery(in);
    }

    /**
     * Converts the given Criteria into a sub-SELECT query, surrounds it in parentheses, and adds a new
     * "NOT IN (...)" condition containing the resulting expression into the WHERE clause, while ANDing
     * the new condition with any existing conditions if necessary.
     *
     * @param attribute An expression representing the left-hand side of the "NOT IN (...)" condition.
     * @param in The Criteria representing the sub-query of the "NOT IN (...)" condition.
     */
    public void notIn(String attribute, Criteria notIn) {
        if (notIn == null) { throw new IllegalArgumentException("'NOT IN' Criteria cannot be null"); }
        preparePrefixIfNecessary(attribute);
        whereClause.append(attribute).append(" NOT IN ");
        subQuery(notIn);
    }

    /**
     * Takes the individual elements of the provided collection, converts them to literals or assigns them to input
     * parameters as needed, and adds a new "IN (...)" condition to the WHERE clause containing those elements,
     * ANDing it with any existing conditions if necessary. String, number, boolean, and Class collection elements
     * will be converted into literals, and all other non-null collection elements will be assigned to input parameters.
     *
     * @param attribute An expression representing the left-hand side of the "IN (...)" condition.
     * @param values The collection of values to check against.
     */
    public void in(String attribute, Collection<?> values) {
        preparePrefixIfNecessary(attribute);
        whereClause.append(attribute).append(" IN (");
        appendBodyOfIn(values);
        whereClause.append(')');
    }

    /**
     * Takes the individual elements of the provided collection, converts them to literals or assigns them to input
     * parameters as needed, and adds a new "IN (...)" condition to the WHERE clause containing those elements,
     * ANDing it with any existing conditions if necessary. String, number, boolean, and Class collection elements
     * will be converted into literals, and all other non-null collection elements will be assigned to input parameters.
     *
     * @param attribute An expression representing the left-hand side of the "NOT IN (...)" condition.
     * @param values The collection of values to check against.
     */
    public void notIn(String attribute, Collection<?> values) {
        preparePrefixIfNecessary(attribute);
        whereClause.append(attribute).append(" NOT IN (");
        appendBodyOfIn(values);
        whereClause.append(')');
    }

    /**
     * Takes the provided values, converts them to literals or assigns them to input parameters as needed, and adds
     * a new "IN (...)" condition to the WHERE clause containing those elements, ANDing it with any existing
     * conditions if necessary. String, number, boolean, and Class values will be converted into literals, and all
     * other non-null values will be assigned to input parameters.
     *
     * @param attribute An expression representing the left-hand side of the "IN (...)" condition.
     * @param values The values to check against.
     */
    public void in(String attribute, Object... values) {
        preparePrefixIfNecessary(attribute);
        whereClause.append(attribute).append(" IN (");
        appendBodyOfIn(Arrays.asList(values));
        whereClause.append(')');
    }

    /**
     * Takes the provided values, converts them to literals or assigns them to input parameters as needed, and adds
     * a new "NOT IN (...)" condition to the WHERE clause containing those elements, ANDing it with any existing
     * conditions if necessary. String, number, boolean, and Class values will be converted into literals, and all
     * other non-null values will be assigned to input parameters.
     *
     * @param attribute An expression representing the left-hand side of the "NOT IN (...)" condition.
     * @param values The values to check against.
     */
    public void notIn(String attribute, Object... values) {
        preparePrefixIfNecessary(attribute);
        whereClause.append(attribute).append(" NOT IN (");
        appendBodyOfIn(Arrays.asList(values));
        whereClause.append(')');
    }

    /*
     * Creates the body of an "IN (...)" condition using the provided collection of values.
     * String, number, and boolean values are converted into literals, and all other
     * non-null values are assigned to input parameters.
     */
    private void appendBodyOfIn(Collection<?> values) {
        Iterator<?> valuesIter = values.iterator();
        if (valuesIter.hasNext()) {
            fixValue(whereClause, valuesIter.next());
            while (valuesIter.hasNext()) {
                whereClause.append(", ");
                fixValue(whereClause, valuesIter.next());
            }
        }
    }

    /**
     * Takes the conditions from the given Criteria's WHERE clause, surrounds them in parentheses, and ANDs
     * the resulting expression with this instance's WHERE clause (or makes the expression become the new
     * WHERE clause of this instance if its current WHERE clause is empty). Any input parameters from the
     * given Criteria will be copied over to this Criteria, and will be renamed as needed if conflicts arise.
     *
     * @param and The Criteria instance whose conditions should be ANDed with those in this Criteria instance.
     */
    public void and(Criteria and) {
        if (and == null) { throw new IllegalArgumentException("'AND' Criteria cannot be null"); }
        if (and.whereClause.length() > 0) {
            int oldLen = whereClause.length();
            preparePrefixIfNecessary(JPA_ALIAS_PREFIX);
            whereClause.append('(').append(and.whereClause).append(')');
            copyParams(and, oldLen, true);
        }
    }

    /**
     * Takes the conditions from the given Criteria's WHERE clause, surrounds them in parentheses, and adds
     * a new "NOT (...)" condition containing the resulting expression to this instance's WHERE clause (or
     * adds a new "AND NOT(...)" condition if the WHERE clause on the existing Criteria is not empty). Any
     * input parameters from the given Criteria will be copied over to this Criteria, and will be renamed
     * as needed if conflicts arise.
     *
     * @param not The Criteria instance whose group of conditions should be negated.
     */
    public void not(Criteria not) {
        if (not == null) { throw new IllegalArgumentException("'NOT' Criteria cannot be null"); }
        if (not.whereClause.length() > 0) {
            int oldLen = whereClause.length();
            preparePrefixIfNecessary(JPA_ALIAS_PREFIX);
            whereClause.append("NOT (").append(not.whereClause).append(')');
            copyParams(not, oldLen, true);
        }
    }

    /**
     * Takes the conditions from the given Criteria's WHERE clause, surrounds them in parentheses, and ORs
     * the resulting expression with this instance's WHERE clause (or makes the expression become the new
     * WHERE clause of this instance if its current WHERE clause is empty). Any input parameters from the
     * given Criteria will be copied over to this Criteria, and will be renamed as needed if conflicts arise.
     *
     * @param or The Criteria instance whose conditions should be ORed with those in this Criteria instance.
     */
    public void or(Criteria or) {
        if (or == null) { throw new IllegalArgumentException("'OR' Criteria cannot be null"); }
        if (or.whereClause.length() > 0) {
            int oldLen = whereClause.length();
            whereClause.append((oldLen > 0) ? " OR (" : "(").append(or.whereClause).append(')');
            copyParams(or, oldLen, true);
        }
    }

    /**
     * Takes the conditions from the given Criteria's WHERE clause, surrounds them in parentheses, and adds
     * a new "OR NOT (...)" condition containing the resulting expression to this instance's WHERE clause (or
     * just adds a new "NOT (...)" condition if its current WHERE clause is empty). Any input parameters from the
     * given Criteria will be copied over to this Criteria, and will be renamed as needed if conflicts arise.
     *
     * @param orNot The Criteria instance whose group of conditions should be negated and then ORed with those in this Criteria instance.
     */
    public void orNot(Criteria orNot) {
        if (orNot == null) { throw new IllegalArgumentException("'OR NOT' Criteria cannot be null"); }
        if (orNot.whereClause.length() > 0) {
            int oldLen = whereClause.length();
            whereClause.append((oldLen > 0) ? " OR NOT (" : "NOT (").append(orNot.whereClause).append(')');
            copyParams(orNot, oldLen, true);
        }
    }

    /**
     * Converts the given Criteria into a sub-SELECT query, surrounds it in parentheses, and adds a new
     * EXISTS condition containing the resulting expression into the WHERE clause, while ANDing the new
     * condition with any existing conditions if necessary.
     *
     * @param exists The Criteria instance representing the sub-query of the EXISTS condition.
     */
    public void exists(Criteria exists) {
        if (exists == null) { throw new IllegalArgumentException("'EXISTS' Criteria cannot be null"); }
        preparePrefixIfNecessary(JPA_ALIAS_PREFIX);
        whereClause.append("EXISTS ");
        subQuery(exists);
    }

    /**
     * Converts the given Criteria into a sub-SELECT query, surrounds it in parentheses, and adds a new
     * NOT EXISTS condition containing the resulting expression into the WHERE clause, while ANDing the
     * new condition with any existing conditions if necessary.
     *
     * @param exists The Criteria instance representing the sub-query of the NOT EXISTS condition.
     */
    public void notExists(Criteria notExists) {
        if (notExists == null) { throw new IllegalArgumentException("'NOT EXISTS' Criteria cannot be null"); }
        preparePrefixIfNecessary(JPA_ALIAS_PREFIX);
        whereClause.append("NOT EXISTS ");
        subQuery(notExists);
    }

    /**
     * Inserts raw JPQL into the WHERE clause. An extra whitespace character will automatically be prepended
     * (if the WHERE clause is non-empty) and appended to the JPQL string.
     *
     * @param jpql The raw JPQL to insert.
     */
    public void rawJpql(String jpql) {
        whereClause.append((whereClause.length() > 0) ? " " : "").append(jpql).append(' ');
    }

    /**
     * Adds a new expression to the GROUP BY clause. If no properly-referenced alias appears in
     * the String expression, it will be assumed that the expression points to something
     * that is accessible on or through the initial entity. See the description of this class
     * for more information on how String expressions are interpreted.
     *
     * @param attribute The expression representing what the query results should be grouped by.
     */
    public void groupBy(String attribute) {
        groupByClause.append((groupByClause.length() > 0) ? ", " : " GROUP BY ");
        if (!attribute.contains(JPA_ALIAS_PREFIX)) {
            groupByClause.append(JPA_INITIAL_ALIAS).append('.');
        }
        groupByClause.append(attribute);
    }

    /**
     * Takes the conditions from the given Criteria's WHERE clause and then ANDs them with this
     * instance's HAVING clause (or makes them become the new HAVING clause of this instance if
     * its current HAVING clause is empty). Any input parameters from the given Criteria will be
     * copied over to this Criteria, and will be renamed as needed if conflicts arise.
     *
     * @param having The Criteria instance whose WHERE clause should represent this instance's HAVING clause (or a piece of it).
     */
    public void having(Criteria having) {
        if (having == null) { throw new IllegalArgumentException("'HAVING' Criteria cannot be null"); }
        if (having.whereClause.length() > 0) {
            int oldLen = havingClause.length();
            havingClause.append((oldLen > 0) ? " AND " : " HAVING ").append(having.whereClause);
            copyParams(having, oldLen, false);
        }
    }

    /**
     * Adds a new expression to the ORDER BY clause. If no properly-referenced alias appears in
     * the String expression, it will be assumed that the expression points to something
     * that is accessible on or through the initial entity. See the description of this class
     * for more information on how String expressions are interpreted.
     *
     * @param attribute The expression representing what the query results should be ordered by.
     * @param sortAscending If true, the order will be ascending; otherwise, it will be descending.
     */
    public void orderBy(String attribute, boolean sortAscending) {
        orderByClause.append((orderByClause.length() > 0) ? ", " : " ORDER BY ");
        if (!attribute.contains(JPA_ALIAS_PREFIX)) {
            orderByClause.append(JPA_INITIAL_ALIAS).append('.');
        }
        orderByClause.append(attribute).append(sortAscending ? " ASC" : " DESC");
    }

    /*
     * Copies the input parameters from the given child Criteria to the current Criteria. Any parameter placeholders from the sub-query will
     * be renamed accordingly if they conflict with those defined by the parent Criteria.
     *
     * It is assumed that the sub-query has already been appended to the clause given by modifyWhereClause
     * (WHERE if true, HAVING if false), starting at the index given by startIndex.
     */
    private void copyParams(Criteria subCriteria, int startIndex, boolean modifyWhereClause) {
        final StringBuilder tempClause = modifyWhereClause ? whereClause : havingClause;
        Map<String,String> modifiedNames = new HashMap<String,String>();
        int paramClose = 0;
        int paramIndex = tempClause.indexOf(JPA_PARAM_PREFIX_WITH_COLON, startIndex);
        String newPlaceholder = null;

        for (Map.Entry<String,Object> param : subCriteria.params.entrySet()) {
            if (params.containsKey(param.getKey())) {
                modifiedNames.put(param.getKey(), addAttr(param.getKey(), param.getValue()));
            } else {
                params.put(param.getKey(), param.getValue());
            }
        }

        while (paramIndex >= 0) {
            paramClose = tempClause.indexOf(JPA_ALIAS_SUFFIX, paramIndex);
            newPlaceholder = modifiedNames.get(tempClause.substring(paramIndex + PARAM_PREFIX_LEN + 2, paramClose - 1));
            if (newPlaceholder != null) {
                tempClause.replace(paramIndex, paramClose + ALIAS_SUFFIX_LEN, newPlaceholder);
            }
            paramIndex = tempClause.indexOf(JPA_PARAM_PREFIX_WITH_COLON, paramIndex + 1);
        }
    }

    /*
     * Converts the given Criteria into a sub-query and appends it to the WHERE clause. Any named aliases of the sub-query will be renamed
     * accordingly if they conflict with those defined by the parent Criteria, and all indexed aliases will be updated accordingly. In
     * addition, the input parameters will be copied over and renamed as needed.
     */
    private void subQuery(Criteria subCriteria) {
        Map<String,String> modifiedAliases = new HashMap<String,String>();
        int count = subCriteria.entityAliases.size();
        int paramIndex = 0;
        int paramClose = 0;
        String newPlaceholder = null;

        for (int i = entityAliases.size() - 1; i >= 0; i--) {
            modifiedAliases.put(JPA_ALIAS_PREFIX + (~i) + JPA_ALIAS_SUFFIX, indexedAliasPlaceholders.get(i));
        }
        for (int i = 0; i < count; i++) {
            String oldAlias = subCriteria.entityAliases.get(i);
            if (!addAlias(oldAlias).equals(oldAlias)) {
                modifiedAliases.put(subCriteria.namedAliasPlaceholders.get(i), namedAliasPlaceholders.get(namedAliasPlaceholders.size() - 1));
            }
            modifiedAliases.put(subCriteria.indexedAliasPlaceholders.get(i), indexedAliasPlaceholders.get(indexedAliasPlaceholders.size() - 1));
        }

        count = whereClause.length();
        whereClause.append(subCriteria.distinct ? "(SELECT DISTINCT " : "(SELECT ").append(subCriteria.selectClause).append(subCriteria.fromClause).append(
                (subCriteria.whereClause.length() > 0) ? " WHERE " : "").append(subCriteria.whereClause).append(
                subCriteria.groupByClause).append(subCriteria.havingClause).append(')');

        paramIndex = whereClause.indexOf(JPA_ALIAS_PREFIX, count);
        while (paramIndex >= 0) {
            paramClose = whereClause.indexOf(JPA_ALIAS_SUFFIX, paramIndex) + ALIAS_SUFFIX_LEN;
            newPlaceholder = modifiedAliases.get(whereClause.substring(paramIndex, paramClose));
            if (newPlaceholder != null) {
                whereClause.replace(paramIndex, paramClose, newPlaceholder);
            }
            paramIndex = whereClause.indexOf(JPA_ALIAS_PREFIX, paramIndex + 1);
        }
        copyParams(subCriteria, count, true);
    }

    /**
     * Converts the current Criteria instance into a JPQL query.
     *
     * @param type An indicator of what type of query should be generated (SELECT, UPDATE, or DELETE).
     * @return A String representing the JPQL query generated by this Criteria instance.
     */
    public String toQuery(QueryByCriteria.QueryByCriteriaType type) {
        return toQuery(type, new String[0]);
    }

    /**
     * Converts the current Criteria instance into a JPQL query. If a SELECT query is desired, then
     * alternative String expressions to insert into the SELECT clause can be specified, though doing
     * so is not required and must be done with care (see below).
     *
     * <p>WARNING! If queryAttr is non-null and has a length greater than zero, and if a SELECT query is
     * desired, then this method will completely overwrite the SELECT clause so that it only contains
     * the expressions given by the queryAttr array.
     *
     * @param type An indicator of what type of query should be generated (SELECT, UPDATE, or DELETE).
     * @param queryAttr (Optional) An array of String expressions to use as the values to be returned by the SELECT clause (if creating a SELECT query).
     * @return A String representing the JPQL query generated by this Criteria instance.
     */
    public String toQuery(QueryByCriteria.QueryByCriteriaType type, String[] queryAttr) {
        StringBuilder newQuery;
        int querySize = selectClause.length() + fromClause.length() + whereClause.length() + groupByClause.length() + havingClause.length() + orderByClause.length() + 7;
        // Construct the Criteria appropriately.
        switch (type) {
            case SELECT :
                if (queryAttr != null && queryAttr.length > 0) {
                    if (selectClause.length() > 0) { selectClause.delete(0, selectClause.length()); }
                    for (int i = 0; i < queryAttr.length; i++) {
                        select(queryAttr[i]);
                    }
                }
                newQuery = new StringBuilder(querySize + (distinct ? 16 : 7)).append(distinct ? "SELECT DISTINCT " : "SELECT ").append(
                        selectClause).append(fromClause).append(whereClause.length() > 0 ? " WHERE " : "").append(whereClause).append(
                        groupByClause).append(havingClause).append(orderByClause);
                break;
            case UPDATE :
                newQuery = new StringBuilder(querySize + setClause.length() + 7).append("UPDATE ").append(initialEntityName).append(" AS ").append(
                        getAlias()).append(setClause).append(whereClause.length() > 0 ? " WHERE " : "").append(whereClause);
                break;
            case DELETE :
                newQuery = new StringBuilder(querySize + 6).append("DELETE").append(fromClause).append(
                        whereClause.length() > 0 ? " WHERE " : "").append(whereClause);
                break;
            default :
                return null;
        }
        return fix(newQuery);
    }

    /**
     * Converts the current Criteria instance into a JPQL SELECT query, but replaces the existing SELECT clause with "SELECT COUNT(*)" instead.
     *
     * @return A JPQL query String given by this Criteria, but with "SELECT COUNT(*)" as the SELECT clause instead.
     */
    public String toCountQuery() {
        StringBuilder newQuery = new StringBuilder(
                fromClause.length() + whereClause.length() + groupByClause.length() + havingClause.length() + orderByClause.length() + 15 + 7).append(
                "SELECT COUNT(*)").append(fromClause).append(whereClause.length() > 0 ? " WHERE " : "").append(whereClause).append(
                groupByClause).append(havingClause).append(orderByClause);
        return fix(newQuery);
    }

    /*
     * Converts all the named and indexed alias/parameter placeholders into the actual aliases/parameters.
     * You can view the resulting JPQL String in the logs by configuring a log4j DEBUG output level for
     * this class.
     */
    private String fix(StringBuilder newQuery) {
        Map<String,String> modifiedAliases = new HashMap<String,String>();
        for (int i = entityAliases.size() - 1; i >= 0; i--) {
            modifiedAliases.put(indexedAliasPlaceholders.get(i), entityAliases.get(i));
            modifiedAliases.put(namedAliasPlaceholders.get(i), entityAliases.get(i));
        }

        // resolve the aliases.
        String newParam = null;
        int paramClose = 0;
        int paramIndex = newQuery.indexOf(JPA_ALIAS_PREFIX);
        while (paramIndex >= 0) {
            paramClose = newQuery.indexOf(JPA_ALIAS_SUFFIX, paramIndex) + ALIAS_SUFFIX_LEN;
            newParam = modifiedAliases.get(newQuery.substring(paramIndex, paramClose));
            if (newParam != null) {
                newQuery.replace(paramIndex, paramClose, newParam);
            } else {
                LOG.error("Detected an unresolvable JPA alias when constructing query: " + newQuery.substring(paramIndex, paramClose));
                throw new IllegalStateException("Detected an unresolvable alias: " + newQuery.substring(paramIndex, paramClose));
            }
            paramIndex = newQuery.indexOf(JPA_ALIAS_PREFIX, paramIndex + 1);
        }

        // Resolve the parameters.
        paramIndex = newQuery.indexOf(JPA_PARAM_PREFIX);
        while (paramIndex >= 0) {
            paramClose = newQuery.indexOf(JPA_ALIAS_SUFFIX, paramIndex);
            newParam = newQuery.substring(paramIndex + PARAM_PREFIX_LEN + 1, paramClose - 1);
            if (params.containsKey(newParam)) {
                newQuery.replace(paramIndex, paramClose + ALIAS_SUFFIX_LEN, newParam);
            } else {
                LOG.error("Detected an unresolvable input parameter when constructing query: " + newQuery.substring(paramIndex, paramClose + ALIAS_SUFFIX_LEN));
                throw new IllegalStateException("Detected an unresolvable input parameter: " + newQuery.substring(paramIndex, paramClose + ALIAS_SUFFIX_LEN));
            }
            paramIndex = newQuery.indexOf(JPA_PARAM_PREFIX, paramIndex + 1);
        }

        String finishedQuery = newQuery.toString();
        if (LOG.isDebugEnabled()) {
            LOG.debug("********** SEARCH JPQL QUERY **********");
            LOG.debug(finishedQuery);
            LOG.debug("***************************************");
        }
        return finishedQuery;
    }

    // Keep this package access so the QueryByCriteria can call it from this package.
    /**
     * Populates the given Query instance with the parameters stored in this Criteria. It is assumed that the given query
     * is using this Criteria's toQuery() or toCountQuery() value as its JPQL String.
     *
     * @param query A JPA Query instance containing this Criteria's toQuery() or toCountQuery() value for its JPQL String.
     */
    public void prepareParameters(Query query) {
        for (Map.Entry<String, Object> param : params.entrySet()) {
            Object value = param.getValue();
            if (value != null) {
                if (value instanceof String) {
                    if (query.getParameter(param.getKey()).getParameterType().equals(java.lang.Boolean.class)) {
                        value = Truth.strToBooleanIgnoreCase((String) value, Boolean.FALSE);
                    } else {
                        //value = ((String)value).replaceAll("\\*", "%");
                    }
                }
                query.setParameter(param.getKey(), value);
            }
        }
    }

    /**
     * Retrieves the current limit on the result set size for this Criteria, if any (only relevant if creating a SELECT query).
     *
     * @return The current limit on the number of results to be returned by this Criteria's query, or null (default) if no such limit has been set.
     */
    public Integer getSearchLimit() {
        return this.searchLimit;
    }

    /**
     * Sets the current limit on the result set size for this Criteria (only relevant if creating a SELECT query).
     *
     * @param searchLimit The new limit on the number of results to be returned by this Criteria's query.
     */
    public void setSearchLimit(Integer searchLimit) {
        this.searchLimit = searchLimit;
    }

    /**
     * Sets whether or not the query should include the DISTINCT keyword in the SELECT clause, if creating a SELECT query.
     * If this property is not set explicitly, it is assumed that DISTINCT should *not* be included in the SELECT clause.
     *
     * @param distinct An indicator for whether to do a SELECT DISTINCT or just a SELECT.
     */
    public void distinct(boolean distinct){
        this.distinct = distinct;
    }

    /**
     * Retrieves the initial alias of this Criteria instance.
     *
     * @return The initial alias.
     */
    public String getAlias() {
        return this.entityAliases.get(0);
    }

    /**
     * Retrieves the alias associated with the given index.
     *
     * @param index The index pointing to a given alias.
     * @return The alias at the given index.
     */
    public String getAlias(int index) {
        return this.entityAliases.get(index);
    }

    /**
     * Retrieves the index that points to the given alias.
     *
     * @param alias The indexed alias.
     * @return The index of the alias, or -1 if no such index was found.
     */
    public int getAliasIndex(String alias) {
        Integer tempIndex = aliasIndexes.get(alias);
        return (tempIndex != null) ? tempIndex.intValue() : -1;
    }

    /**
     * Retrieves a copy of all the aliases defined for this Criteria instance.
     * The index of a given alias corresponds to the index at which the alias
     * is located at in the returned List.
     *
     * @return A List containing all the defined aliases of this Criteria instance.
     */
    public List<String> getAliases() {
        return new ArrayList(this.entityAliases);
    }

    /**
     * @return the name of the class of the initial Entity this Criteria will search for
     */
    public String getEntityName() {
        return this.initialEntityName;
    }
}

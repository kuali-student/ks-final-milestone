<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dict="http://student.kuali.org/xsd/dictionary-extension"
	xsi:schemaLocation="
http://student.kuali.org/xsd/dictionary-extension http://student.kuali.org/xsd/dictionary-extension/dictionary-extension.xsd
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
">
	<!-- Added these constrains because they were referenced by other beans but did not exist-->
	<dict:constraint key="calculated" id="calculated">
	</dict:constraint>
	
	<dict:constraint key="repeating" id="repeating">
	</dict:constraint>
	
	<dict:constraint key="hard.coded.official" id="hard.coded.official">
	</dict:constraint>

	<dict:constraint key="hard.coded.active" id="hard.coded.active">
	</dict:constraint>

	<dict:constraint key="hard.coded.cross-listed" id="hard.coded.cross-listed">
	</dict:constraint>

	<dict:constraint key="hard.coded.version" id="hard.coded.version">
	</dict:constraint>
	<!--  End  -->
	
		
	<dict:constraint key="required" id="required">
		<!-- Required -->
		<dict:minOccurs>1</dict:minOccurs>
	</dict:constraint>
	<dict:constraint key="optional" id="optional">
		<!-- Optional -->
		<!--
			Used to override a previous required constraint. Also implied by the
			absence of a required constraint
		-->
		<dict:minOccurs>0</dict:minOccurs>
	</dict:constraint>
	<dict:constraint key="not.used" id="not.used">
		<!-- Not Used -->
		<dict:minOccurs>0</dict:minOccurs>
		<dict:maxOccurs>0</dict:maxOccurs>
	</dict:constraint>
	<dict:constraint key="code" id="code">
		<!-- Alphanumeric code, hypen and period. -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:validChars>
			<dict:value>regex:[A-Za-z0-9.-]*</dict:value>
		</dict:validChars>
	</dict:constraint>
	<dict:constraint key="uppercase" id="uppercase">
		<!-- uppercase alphanumeric code, hypen and period. -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:validChars>
			<dict:value>regex:[A-Z0-9.-]*</dict:value>
		</dict:validChars>
	</dict:constraint>
	<dict:constraint key="lowercase" id="lowercase">
		<!-- lowercase alphanumeric code, hypen and period. -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:validChars>
			<dict:value>regex:[a-z0-9.-]*</dict:value>
		</dict:validChars>
	</dict:constraint>
	<dict:constraint key="free.text" id="free.text">
		<!--
			Free form text field; most characters allowed except carraige-return,
			line-feed, tabs, etc.
		-->
		<!-- What about international characters? -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>255</dict:maxLength>
		<dict:validChars>
			<dict:value><![CDATA[ regex:[A-Za-z0-9.-;;&apos;&amp;%$#@!]*]]></dict:value>
		</dict:validChars>
	</dict:constraint>
	<dict:constraint key="plain.text" id="plain.text">
		<!--
			Multi-line text field that accepts most standard characters plus
			carraige-return and linefeed.
		-->
		<dict:minLength>1</dict:minLength>
		<dict:validChars>
			<dict:value><![CDATA[regex:[A-Za-z0-9.-;;&apos;&amp;%$#@!\n\r\t]*]]></dict:value>
		</dict:validChars>
	</dict:constraint>
	<dict:constraint key="rich.text" id="rich.text">
		<!-- Multi-line text field that accepts all types of characters -->
		<!--
			Not sure rich text means we need to allow all types of characters
		-->
		<dict:minLength>1</dict:minLength>
	</dict:constraint>
	<dict:constraint key="date" id="date">
		<!-- Date -->
		<!-- http://regexlib.com/REDetails.aspx?regexp_id=760 (but not sure) -->
		<dict:minLength>10</dict:minLength>
		<dict:maxLength>10</dict:maxLength>
	</dict:constraint>
	<dict:constraint key="date.time" id="date.time">
		<!-- Date-Time -->
		<!--
			http://regexlib.com/REDetails.aspx?regexp_id=1966 (but not sure)
		-->
		<dict:minLength>19</dict:minLength>
		<dict:maxLength>19</dict:maxLength>
	</dict:constraint>
	<dict:constraint key="integer" id="integer">
		<!-- Integer -->
		<!-- http://regexlib.com/REDetails.aspx?regexp_id=14 -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>10</dict:maxLength>
		<dict:validChars>
			<dict:value>regex:^(\+|-)?\d+$</dict:value>
		</dict:validChars>
	</dict:constraint>
	<dict:constraint key="positive.integer" id="positive.integer">
		<!-- Positive Integer -->
		<!-- http://regexlib.com/REDetails.aspx?regexp_id=13 -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>10</dict:maxLength>
		<dict:validChars>
			<dict:value>regex:^\d+$</dict:value>
		</dict:validChars>
	</dict:constraint>
	<dict:constraint key="decimal" id="decimal">
		<!-- decimal number -->
		<!-- http://regexlib.com/REDetails.aspx?regexp_id=117 -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>10</dict:maxLength>
		<dict:validChars>
			<dict:value>regex:^[-+]?\d+(\.\d+)?$
			</dict:value>
		</dict:validChars>
	</dict:constraint>
	<dict:constraint key="amount" id="amount">
		<!-- Amount field -->
		<!-- http://regexlib.com/REDetails.aspx?regexp_id=131 -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>10</dict:maxLength>
		<dict:validChars>
			<dict:value>regex:^\$?\d+(\.(\d{2}))?$
			</dict:value>
		</dict:validChars>
	</dict:constraint>
	<dict:constraint key="kuali.id" id="kuali.id"
		serverSide="true">
		<!-- Kuali ID; calculated by service on add, then read-only. -->
		<dict:minOccurs>1</dict:minOccurs>
		<dict:maxOccurs>1</dict:maxOccurs>
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>36</dict:maxLength>
	</dict:constraint>
	<dict:constraint key="kuali.type" id="kuali.type"
		serverSide="true">
		<!-- Kuali TYPE: required on add, then read-only -->
		<dict:minOccurs>1</dict:minOccurs>
		<dict:maxOccurs>1</dict:maxOccurs>
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:validChars>
			<dict:value>regex:[A-Za-z0-9.-]*</dict:value>
		</dict:validChars>
	</dict:constraint>
	<dict:constraint key="kuali.state" id="kuali.state"
		serverSide="true">
		<!-- Kuali STATE: required -->
		<dict:minOccurs>1</dict:minOccurs>
		<dict:maxOccurs>1</dict:maxOccurs>
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>30</dict:maxLength>
		<dict:validChars>
			<dict:value>regex:[A-Za-z0-9.-]*</dict:value>
		</dict:validChars>
	</dict:constraint>
	<dict:constraint key="kuali.meta.data" id="kuali.meta.data"
		serverSide="true">
		<!-- Kuali Meta Data: calculated by service, read-only -->
		<dict:minOccurs>1</dict:minOccurs>
		<dict:maxOccurs>1</dict:maxOccurs>
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>36</dict:maxLength>
	</dict:constraint>
	<dict:constraint key="related.cluId" id="related.cluId"
		serverSide="true">
		<!-- Id of an existing CLU -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>36</dict:maxLength>
	</dict:constraint>
	<dict:constraint key="related.orgId" id="related.orgId"
		serverSide="true">
		<!-- Id of an existing ORG -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>36</dict:maxLength>
	</dict:constraint>
	<dict:constraint key="related.principalId" id="related.principalId"
		serverSide="true">
		<!-- Id of an existing PRINCIPAL -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>36</dict:maxLength>
	</dict:constraint>
	<dict:constraint key="lu.types" id="lu.types">
		<!-- In list of configured learning unit types -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.lu.types">
			<dict:lookupKey field="(none)" mapsTo="(none)" />
		</dict:lookup>
	</dict:constraint>
	<dict:constraint key="lu.identifier.types" id="lu.identifier.types">
		<!-- In list of configured clu identifier types -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.lu.identifier.types">
			<dict:lookupKey field="(none)" mapsTo="(none)" />
		</dict:lookup>
	</dict:constraint>
	<dict:constraint key="duration.types" id="duration.types">
		<!-- In list of configured duration types -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.durationTypes">
			<dict:lookupKey field="(none)" mapsTo="(none)" />
		</dict:lookup>
	</dict:constraint>
	<dict:constraint key="instructional.format.types" id="instructional.format.types">
		<!-- In list of configured instructional formats -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>30</dict:maxLength>
		<dict:lookup search="kuali.enum.type.instructionalFormatTypes">
			<dict:lookupKey field="(none)" mapsTo="(none)" />
		</dict:lookup>
	</dict:constraint>
	<dict:constraint key="season.types" id="season.types">
		<!-- In list of configured seasons -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.seasonTypes">
			<dict:lookupKey field="(none)" mapsTo="(none)" />
		</dict:lookup>
	</dict:constraint>
	<dict:constraint key="atp.types" id="atp.types">
		<!-- In list of configured  time period types -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.atpTypes">
			<dict:lookupKey field="(none)" mapsTo="(none)" />
		</dict:lookup>
	</dict:constraint>
	<dict:constraint key="dynamic.field.types" id="dynamic.field.types">
		<!-- In list of configured dynamic field types -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.dynamicFieldTypes">
			<dict:lookupKey field="(none)" mapsTo="(none)" />
		</dict:lookup>
	</dict:constraint>
	<dict:constraint key="clu.clu.relation.types" id="clu.clu.relation.types">
		<!-- In list of configured clul-clu relation types -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.clu.clu.relation.types">
			<dict:lookupKey field="(none)" mapsTo="(none)" />
		</dict:lookup>
	</dict:constraint>
	<dict:constraint key="lu.states" id="lu.states">
		<!-- In list of configured learning unit states -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>30</dict:maxLength>
		<dict:lookup search="kuali.enum.type.lu.states">
			<dict:lookupKey field="(none)" mapsTo="(none)" />
		</dict:lookup>
	</dict:constraint>
	<dict:constraint key="lu.identifier.states" id="lu.identifier.states">
		<!-- In list of configured clu identifier states -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>30</dict:maxLength>
		<dict:lookup search="kuali.enum.type.lu.identifier.states">
			<dict:lookupKey field="(none)" mapsTo="(none)" />
		</dict:lookup>
	</dict:constraint>
	<dict:constraint key="subject.area" id="subject.area">
		<!-- In list of configured subject areas -->
		<dict:minLength>4</dict:minLength>
		<dict:maxLength>4</dict:maxLength>
		<dict:validChars>
			<dict:value>regex:[A-Z]*</dict:value>
		</dict:validChars>
		<dict:lookup search="kuali.enum.type.subjectArea">
			<dict:lookupKey field="(none)" mapsTo="(none)" />
		</dict:lookup>
	</dict:constraint>
	<dict:constraint key="available.course.numbers" id="available.course.numbers">
		<!-- In list of configured available course numbers -->
		<dict:minLength>3</dict:minLength>
		<dict:maxLength>3</dict:maxLength>
		<dict:validChars>
			<dict:value>regex:[0-9]*</dict:value>
		</dict:validChars>
		<dict:lookup search="kuali.enum.type.availableNumbers">
			<dict:lookupKey field="(none)" mapsTo="(none)" />
		</dict:lookup>
	</dict:constraint>
	<dict:constraint key="offering.campuses" id="offering.campuses">
		<!-- In list of configured offering campuses -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>30</dict:maxLength>
		<dict:lookup search="kuali.enum.type.offeringCampuses">
			<dict:lookupKey field="(none)" mapsTo="(none)" />
		</dict:lookup>
	</dict:constraint>
	<dict:constraint key="unit.types" id="unit.types">
		<!-- In list of configured unit types -->
		<!--
			Although called a type, this is not a formal type in kuali student
			like an lu type, for example it may be changeable after being added.
		-->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>10</dict:maxLength>
		<dict:lookup search="kuali.enum.type.validUnitTypes">
			<dict:lookupKey field="(none)" mapsTo="(none)" />
		</dict:lookup>
	</dict:constraint>

	<dict:objectStructure key="cluInfo">
		<!-- Detailed information about a single CLU. -->
		<dict:type key="kuali.lu.type.CreditCourse">
			<!-- A course offered for academic credit -->
			<!-- Subject, Academic Course -->
			<dict:state key="template">
				<!--
					A template holds configuration for defaults for creating a new
					course
				-->
				<!--
					Not sure if this is needed but UC mentions some ability for
					professors to create proposals within their own space
				-->

				<dict:field id="course.no" key="officialIdentifier">
					<dict:fieldDescriptor>
						<dict:name>course.no</dict:name>
						<dict:desc>course no</dict:desc>
						<dict:dataType>complex</dict:dataType>

						<dict:objectStructure key="cluIdentifierInfo">
							<!--
								Detailed information about the human readable form of a CLU
								Identifier
							-->
							<dict:type key="kuali.lu.type.CreditCourse.identifier.official">
								<!-- This identifier holds the official identifier for this course -->
								<dict:state key="active">
									<!-- Identifier is active -->
									<!--
										TODO: Worry about states overlapping across xmlObjects. The
										lookup on thge Dictionary worksheet will grab the wrong one
									-->

									<dict:field id="course.official.no" key="code">
										<dict:fieldDescriptor>
											<dict:name>course.official.no</dict:name>
											<dict:desc>course number</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="code"/>
											<dict:constraintRef bean="calculated"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.official.transcriptTitle"
										key="shortName">
										<dict:fieldDescriptor>
											<dict:name>course.official.transcriptTitle</dict:name>
											<dict:desc>transcript title</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="free.text"/>
											<dict:constraintRef bean="required"/>

											<dict:constraint key="course.official.transcriptTitle">
												<dict:maxLength>20</dict:maxLength>
											</dict:constraint>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.official.catalogTitle" key="longName">
										<dict:fieldDescriptor>
											<dict:name>course.official.catalogTitle</dict:name>
											<dict:desc>catalog title</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="free.text"/>
											<dict:constraintRef bean="required"/>

											<dict:constraint key="course.official.catalogTitle">
												<dict:maxLength>60</dict:maxLength>
											</dict:constraint>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.official.level" key="level">
										<dict:fieldDescriptor>
											<dict:name>course.official.level</dict:name>
											<dict:desc>level</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="code"/>
											<dict:constraintRef bean="not.used"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.official.subjectArea" key="division">
										<dict:fieldDescriptor>
											<dict:name>course.official.subjectArea</dict:name>
											<dict:desc>subject area</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="code"/>
											<dict:constraintRef bean="required"/>
											<dict:constraintRef bean="subject.area"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.official.numberPart" key="suffixCode">
										<dict:fieldDescriptor>
											<dict:name>course.official.numberPart</dict:name>
											<dict:desc>number part of the course number</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="code"/>
											<dict:constraintRef bean="required"/>
											<dict:constraintRef bean="available.course.numbers"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.official.version" key="variation">
										<dict:fieldDescriptor>
											<dict:name>course.official.version</dict:name>
											<dict:desc>version code</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="code"/>
											<dict:constraintRef bean="not.used"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.official.adminOrg" key="orgId">
										<dict:fieldDescriptor>
											<dict:name>course.official.adminOrg</dict:name>
											<dict:desc>dept</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="related.orgId"/>
											<dict:constraintRef bean="not.used"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.official.type" key="type">
										<!-- Required when first adding but read-only thereafter -->
										<dict:fieldDescriptor>
											<dict:name>course.official.type</dict:name>
											<dict:desc>official</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="kuali.type"/>
											<dict:constraintRef bean="lu.identifier.types"/>
											<dict:constraintRef bean="hard.coded.official"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.official.state" key="state">
										<dict:fieldDescriptor>
											<dict:name>course.official.state</dict:name>
											<dict:desc>state</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="kuali.state"/>
											<dict:constraintRef bean="lu.identifier.states"/>
											<dict:constraintRef bean="hard.coded.active"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.official.internalId" key="id">
										<!--
											should be blank when first adding but required thereafter for
											updates
										-->
										<dict:fieldDescriptor>
											<dict:name>course.official.internalId</dict:name>
											<dict:desc>internal id of this id</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="kuali.id"/>
										</dict:constraintDescriptor>
									</dict:field>
								</dict:state>
								<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<dict:fieldRef bean="course.official.no"/>
									<dict:fieldRef bean="course.official.transcriptTitle"/>
									<dict:fieldRef bean="course.official.catalogTitle"/>
									<dict:fieldRef bean="course.official.level"/>
									<dict:fieldRef bean="course.official.subjectArea"/>
									<dict:fieldRef bean="course.official.numberPart"/>
									<dict:fieldRef bean="course.official.version"/>
									<dict:fieldRef bean="course.official.adminOrg"/>
									<dict:fieldRef bean="course.official.type"/>
									<dict:fieldRef bean="course.official.state"/>
									<dict:fieldRef bean="course.official.internalId"/>
								</dict:state>
							</dict:type>
							<dict:type key="kuali.lu.type.CreditCourse.identifier.cross-listed">
								<!--
									This identifier holds the cross-listed identifiers for this
									course
								-->
								<!-- (MIT's meaning of joint) -->
								<dict:state key="active">
									<!-- Identifier is active -->
									<!--
										TODO: Worry about states overlapping across xmlObjects. The
										lookup on thge Dictionary worksheet will grab the wrong one
									-->
								</dict:state>
								<dict:state key="inactive">
									<!-- Identifier is inactive -->
								</dict:state>
							</dict:type>
							<dict:type key="kuali.lu.type.CreditCourse.identifier.version">
								<!--
									This identifier holds the version information for courses that
									have multiple versions
								-->
								<!-- Variation -->
								<dict:state key="active">
									<!-- Identifier is active -->
									<!--
										TODO: Worry about states overlapping across xmlObjects. The
										lookup on thge Dictionary worksheet will grab the wrong one
									-->
								</dict:state>
								<dict:state key="inactive">
									<!-- Identifier is inactive -->
								</dict:state>
							</dict:type>
						</dict:objectStructure>
											<dict:search key="lalala"/>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.alternateIdentifiers" key="alternateIdentifiers">
					<dict:fieldDescriptor>
						<dict:name>course.alternateIdentifiers</dict:name>
						<dict:desc>course alternate ids</dict:desc>
						<dict:dataType>complex</dict:dataType>

						<dict:objectStructure key="cluIdentifierInfo">
							<!--
								Detailed information about the human readable form of a CLU
								Identifier
							-->
							<dict:type key="kuali.lu.type.CreditCourse.identifier.official">
								<!-- This identifier holds the official identifier for this course -->
								<dict:state key="active">
									<!-- Identifier is active -->
									<!--
										TODO: Worry about states overlapping across xmlObjects. The
										lookup on thge Dictionary worksheet will grab the wrong one
									-->
								</dict:state>
								<dict:state key="inactive">
									<!-- Identifier is inactive -->
								</dict:state>
							</dict:type>
							<dict:type key="kuali.lu.type.CreditCourse.identifier.cross-listed">
								<!--
									This identifier holds the cross-listed identifiers for this
									course
								-->
								<!-- (MIT's meaning of joint) -->
								<dict:state key="active">
									<!-- Identifier is active -->
									<!--
										TODO: Worry about states overlapping across xmlObjects. The
										lookup on thge Dictionary worksheet will grab the wrong one
									-->

									<dict:field id="course.cross-listed.no" key="code">
										<dict:fieldDescriptor>
											<dict:name>course.cross-listed.no</dict:name>
											<dict:desc>cross-listed number</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="code"/>
											<dict:constraintRef bean="calculated"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.cross-listed.transcriptTitle"
										key="shortName">
										<dict:fieldDescriptor>
											<dict:name>course.cross-listed.transcriptTitle</dict:name>
											<dict:desc>not used</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="free.text"/>
											<dict:constraintRef bean="not.used"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.cross-listed.catalogTitle"
										key="longName">
										<dict:fieldDescriptor>
											<dict:name>course.cross-listed.catalogTitle</dict:name>
											<dict:desc>not used</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="free.text"/>
											<dict:constraintRef bean="not.used"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.cross-listed.level" key="level">
										<dict:fieldDescriptor>
											<dict:name>course.cross-listed.level</dict:name>
											<dict:desc>not used</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="code"/>
											<dict:constraintRef bean="not.used"/>
										</dict:constraintDescriptor>
										<dict:dynamic>true</dict:dynamic>
									</dict:field>

									<dict:field id="course.cross-listed.subjectArea"
										key="division">
										<dict:fieldDescriptor>
											<dict:name>course.cross-listed.subjectArea</dict:name>
											<dict:desc>cross-listed subject area</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="code"/>
											<dict:constraintRef bean="required"/>
											<dict:constraintRef bean="subject.area"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.cross-listed.numberPart" key="suffixCode">
										<dict:fieldDescriptor>
											<dict:name>course.cross-listed.numberPart</dict:name>
											<dict:desc>number part of cross-listed number</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="code"/>
											<dict:constraintRef bean="required"/>
											<dict:constraintRef bean="available.course.numbers"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.cross-listed.version" key="variation">
										<dict:fieldDescriptor>
											<dict:name>course.cross-listed.version</dict:name>
											<dict:desc>not used</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="code"/>
											<dict:constraintRef bean="not.used"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.cross-listed.adminOrg" key="orgId">
										<dict:fieldDescriptor>
											<dict:name>course.cross-listed.adminOrg</dict:name>
											<dict:desc>cross-listed department</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="related.orgId"/>
											<dict:constraintRef bean="required"/>
											<dict:constraintRef bean="related.orgId"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.cross-listed.type" key="type">
										<!-- Required when first adding but read-only thereafter -->
										<dict:fieldDescriptor>
											<dict:name>course.cross-listed.type</dict:name>
											<dict:desc>cross-listed</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="kuali.type"/>
											<dict:constraintRef bean="lu.identifier.types"/>
											<dict:constraintRef bean="hard.coded.cross-listed"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.cross-listed.state" key="state">
										<dict:fieldDescriptor>
											<dict:name>course.cross-listed.state</dict:name>
											<dict:desc>state</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="kuali.state"/>
											<dict:constraintRef bean="lu.identifier.states"/>
											<dict:constraintRef bean="hard.coded.active"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.cross-listed.internalId" key="id">
										<!--
											should be blank when first adding but required thereafter for
											updates
										-->
										<dict:fieldDescriptor>
											<dict:name>course.cross-listed.internalId</dict:name>
											<dict:desc>internal id of cross-listed id</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="kuali.id"/>
										</dict:constraintDescriptor>
									</dict:field>
								</dict:state>
								<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<dict:fieldRef bean="course.cross-listed.no"/>
									<dict:fieldRef bean="course.cross-listed.transcriptTitle"/>
									<dict:fieldRef bean="course.cross-listed.catalogTitle"/>
									<dict:fieldRef bean="course.cross-listed.level"/>
									<dict:fieldRef bean="course.cross-listed.subjectArea"/>
									<dict:fieldRef bean="course.cross-listed.numberPart"/>
									<dict:fieldRef bean="course.cross-listed.version"/>
									<dict:fieldRef bean="course.cross-listed.adminOrg"/>
									<dict:fieldRef bean="course.cross-listed.type"/>
									<dict:fieldRef bean="course.cross-listed.state"/>
									<dict:fieldRef bean="course.cross-listed.internalId"/>
								</dict:state>
							</dict:type>
							<dict:type key="kuali.lu.type.CreditCourse.identifier.version">
								<!--
									This identifier holds the version information for courses that
									have multiple versions
								-->
								<!-- Variation -->
								<dict:state key="active">
									<!-- Identifier is active -->
									<!--
										TODO: Worry about states overlapping across xmlObjects. The
										lookup on thge Dictionary worksheet will grab the wrong one
									-->

									<dict:field id="course.version.no" key="code">
										<!--
											calculated by concatenating the subjecare, numberPart and
											version code.
										-->
										<dict:fieldDescriptor>
											<dict:name>course.version.no</dict:name>
											<dict:desc>version number</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="code"/>
											<dict:constraintRef bean="calculated"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.version.transcriptTitle" key="shortName">
										<dict:fieldDescriptor>
											<dict:name>course.version.transcriptTitle</dict:name>
											<dict:desc>not used</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="free.text"/>
											<dict:constraintRef bean="not.used"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.version.catalogTitle" key="longName">
										<!--
											Not sure this should actually be stored in the shortName
											field instead (or in-addition to) storing it in the longName
											field
										-->
										<dict:fieldDescriptor>
											<dict:name>course.version.catalogTitle</dict:name>
											<dict:desc>not used</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="free.text"/>
											<dict:constraintRef bean="required"/>

											<dict:constraint key="course.version.catalogTitle">
												<dict:maxLength>20</dict:maxLength>
											</dict:constraint>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.version.level" key="level">
										<dict:fieldDescriptor>
											<dict:name>course.version.level</dict:name>
											<dict:desc>not used</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="code"/>
											<dict:constraintRef bean="not.used"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.version.subjectArea" key="division">
										<!-- set to the official number's subjectArea -->
										<dict:fieldDescriptor>
											<dict:name>course.version.subjectArea</dict:name>
											<dict:desc>subject area</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="code"/>
											<dict:constraintRef bean="calculated"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.version.numberPart" key="suffixCode">
										<!-- set to the official number's numberPart -->
										<dict:fieldDescriptor>
											<dict:name>course.version.numberPart</dict:name>
											<dict:desc>number part of course number</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="code"/>
											<dict:constraintRef bean="calculated"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.version.version" key="variation">
										<dict:fieldDescriptor>
											<dict:name>course.version.version</dict:name>
											<dict:desc>version code</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="code"/>
											<dict:constraintRef bean="required"/>

											<dict:constraint key="course.version.version">
												<dict:maxLength>1</dict:maxLength>
												<dict:validChars>
													<dict:value>regex:[A-Z]</dict:value>
												</dict:validChars>
											</dict:constraint>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.version.adminOrg" key="orgId">
										<dict:fieldDescriptor>
											<dict:name>course.version.adminOrg</dict:name>
											<dict:desc>not used</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="related.orgId"/>
											<dict:constraintRef bean="not.used"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.version.type" key="type">
										<!-- Required when first adding but read-only thereafter -->
										<dict:fieldDescriptor>
											<dict:name>course.version.type</dict:name>
											<dict:desc>version</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="kuali.type"/>
											<dict:constraintRef bean="lu.identifier.types"/>
											<dict:constraintRef bean="hard.coded.version"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.version.state" key="state">
										<dict:fieldDescriptor>
											<dict:name>course.version.state</dict:name>
											<dict:desc>state</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="kuali.state"/>
											<dict:constraintRef bean="lu.identifier.states"/>
											<dict:constraintRef bean="hard.coded.active"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.version.internalId" key="id">
										<!--
											should be blank when first adding but required thereafter for
											updates
										-->
										<dict:fieldDescriptor>
											<dict:name>course.version.internalId</dict:name>
											<dict:desc>internal id of this course version</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="kuali.id"/>
										</dict:constraintDescriptor>
									</dict:field>
								</dict:state>
								<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<dict:fieldRef bean="course.version.no"/>
									<dict:fieldRef bean="course.version.transcriptTitle"/>
									<dict:fieldRef bean="course.version.catalogTitle"/>
									<dict:fieldRef bean="course.version.level"/>
									<dict:fieldRef bean="course.version.subjectArea"/>
									<dict:fieldRef bean="course.version.numberPart"/>
									<dict:fieldRef bean="course.version.version"/>
									<dict:fieldRef bean="course.version.adminOrg"/>
									<dict:fieldRef bean="course.version.type"/>
									<dict:fieldRef bean="course.version.state"/>
									<dict:fieldRef bean="course.version.internalId"/>
								</dict:state>
							</dict:type>
						</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="repeating"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.campusLocation" key="campusLocationInfo">
					<!--
						The message structure goes to another substructure but that just
						holds a string so I don't thnk that is needed and I changed the
						name to "Info" instead of "List" which is on the un-needed
						sub-structure
					-->
					<dict:fieldDescriptor>
						<dict:name>course.campusLocation</dict:name>
						<dict:desc>campus location</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="repeating"/>
						<dict:constraintRef bean="code"/>
						<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>course.desc</dict:name>
						<dict:desc>dscription</dict:desc>
						<dict:dataType>complex</dict:dataType>

						<dict:objectStructure key="richTextInfo">
							<!--
								Complex type supporting both a plain text and formatted version
								of a string.
							-->
							<dict:type key="(n/a)">
								<!-- Not applicable -->
								<dict:state key="(n/a)">
									<!-- Not applicable -->
								</dict:state>
							</dict:type>
						</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.rationale" key="marketingDesc">
					<!--
						Not used in KRU but wanted an example of multiple RichText fields
					-->
					<!-- Rationale is stored in the Marketing Description for now -->
					<dict:fieldDescriptor>
						<dict:name>course.rationale</dict:name>
						<dict:desc>rationale</dict:desc>
						<dict:dataType>complex</dict:dataType>

						<dict:objectStructure key="richTextInfo">
							<!--
								Complex type supporting both a plain text and formatted version
								of a string.
							-->
							<dict:type key="(n/a)">
								<!-- Not applicable -->
								<dict:state key="(n/a)">
									<!-- Not applicable -->
								</dict:state>
							</dict:type>
						</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.primaryAdminOrg" key="primaryAdminOrg">
					<!--
						Services has this on it's own structure called AdminOrgInfo that
						allows for dynamic fields to be attached to the org but I am not
						modeling that right now so I don't have to go to 3 levels.
					-->
					<dict:fieldDescriptor>
						<dict:name>course.primaryAdminOrg</dict:name>
						<dict:desc>department</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="related.orgId"/>
						<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>

				<dict:field id="course.alternateAdminOrgs" key="alternateAdminOrgs">
					<!--
						Services has this on it's own structure called AdminOrgInfo that
						allows for dynamic fields to be attached to the org but I am not
						modeling that right now so I don't have to go to 3 levels.
					-->
					<dict:fieldDescriptor>
						<dict:name>course.alternateAdminOrgs</dict:name>
						<dict:desc>not used</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="repeating"/>
						<dict:constraintRef bean="related.orgId"/>
						<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>course.effectiveDate</dict:name>
						<dict:desc>first date can be offered</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="date"/>
						<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>course.expirationDate</dict:name>
						<dict:desc>last date can be offerred</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="date"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.contact.hours" key="intensity">
					<dict:fieldDescriptor>
						<dict:name>course.contact.hours</dict:name>
						<dict:desc>contact hours</dict:desc>
						<dict:dataType>complex</dict:dataType>

						<dict:objectStructure key="amountInfo">
							<!--
								Detailed information about an amount including both the type of
								units and the quantity.
							-->
							<dict:type key="(n/a)">
								<!-- Not applicable -->
								<dict:state key="(n/a)">
									<!-- Not applicable -->
								</dict:state>
							</dict:type>
						</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.duration" key="stdDuration">
					<dict:fieldDescriptor>
						<dict:name>course.duration</dict:name>
						<dict:desc>duration</dict:desc>
						<dict:dataType>complex</dict:dataType>

						<dict:objectStructure key="timeAmountInfo">
							<!--
								Detailed information about an amount of time including both the
								type of units and the quantity.
							-->
							<dict:type key="(n/a)">
								<!-- Not applicable -->
								<dict:state key="(n/a)">
									<!-- Not applicable -->
								</dict:state>
							</dict:type>
						</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.seasons" key="offeredAtpTypes">
					<!--
						Services has this as an atpKeyList but that is just a list of
						Strings so I didn't create the sub-structure
					-->
					<dict:fieldDescriptor>
						<dict:name>course.seasons</dict:name>
						<dict:desc>seasons offered</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="repeating"/>
						<dict:constraintRef bean="atp.types"/>
						<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.dynamic.attributes" key="attributes">
					<!--
						Services has this as an attributeInfoList but that is just a list
						of the attributeInfo substructure so I did't create the
						intermediary list sub-structure
					-->
					<dict:fieldDescriptor>
						<dict:name>course.dynamic.attributes</dict:name>
						<dict:desc>not used</dict:desc>
						<dict:dataType>complex</dict:dataType>

						<dict:objectStructure key="attributeInfo">
							<!-- List of key/value pairs, typically used for dynamic attributes. -->
							<dict:type key="(n/a)">
								<!-- Not applicable -->
								<dict:state key="(n/a)">
									<!-- Not applicable -->
								</dict:state>
							</dict:type>
						</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="repeating"/>
						<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.meta" key="metaInfo">
					<!-- must be empty on create but required on update -->
					<dict:fieldDescriptor>
						<dict:name>course.meta</dict:name>
						<dict:desc>audit trail info</dict:desc>
						<dict:dataType>complex</dict:dataType>

						<dict:objectStructure key="metaInfo">
							<!--
								Create and last update info for the structure. This is optional
								and treated as read only since the data is set by the internals
								of the service during maintenance operations.
							-->
							<dict:type key="(n/a)">
								<!-- Not applicable -->
								<dict:state key="(n/a)">
									<!-- Not applicable -->
								</dict:state>
							</dict:type>
						</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="kuali.meta.data"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.type" key="type">
					<!-- Requierd on the create but read-only after that -->
					<dict:fieldDescriptor>
						<dict:name>course.type</dict:name>
						<dict:desc>type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="kuali.type"/>
						<dict:constraintRef bean="lu.types"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>course.state</dict:name>
						<dict:desc>state</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="kuali.state"/>
						<dict:constraintRef bean="lu.states"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>

				<dict:field id="course.internalId" key="id">
					<!-- must be empty on create but required on update -->
					<dict:fieldDescriptor>
						<dict:name>course.internalId</dict:name>
						<dict:desc>internal id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="kuali.id"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="explore">
				<!-- Exploratory/Private scratch pad -->
				<!--
					Not sure if this is needed but UC mentions some ability for
					professors to create proposals within their own space
				-->
				<dict:fieldRef bean="course.no"/>
				<dict:fieldRef bean="course.alternateIdentifiers"/>
				<dict:fieldRef bean="course.campusLocation"/>
				<dict:fieldRef bean="course.desc"/>
				<dict:fieldRef bean="course.rationale"/>
				<dict:fieldRef bean="course.primaryAdminOrg"/>
				<dict:fieldRef bean="course.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.effectiveDate"/>
				<dict:fieldRef bean="course.expirationDate"/>
				<dict:fieldRef bean="course.contact.hours"/>
				<dict:fieldRef bean="course.duration"/>
				<dict:fieldRef bean="course.seasons"/>
				<dict:fieldRef bean="course.dynamic.attributes"/>
				<dict:fieldRef bean="course.meta"/>
				<dict:fieldRef bean="course.type"/>
				<dict:fieldRef bean="course.state"/>
				<dict:fieldRef bean="course.internalId"/>
			</dict:state>
			<dict:state key="draft">
				<!-- Entered as draft but not yet submitted -->

				<dict:field id="course.no.draft" key="officialIdentifier">
					<dict:fieldDescriptor>
						<dict:name>course.no</dict:name>
						<dict:desc>course no</dict:desc>
						<dict:dataType>complex</dict:dataType>

						<dict:objectStructure key="cluIdentifierInfo">
							<!--
								Detailed information about the human readable form of a CLU
								Identifier
							-->
							<dict:type key="kuali.lu.type.CreditCourse.identifier.official">
								<!-- This identifier holds the official identifier for this course -->
								<dict:state key="active">
									<!-- Identifier is active -->
									<!--
										TODO: Worry about states overlapping across xmlObjects. The
										lookup on thge Dictionary worksheet will grab the wrong one
									-->
									<dict:fieldRef bean="course.official.no"/>
									<dict:fieldRef bean="course.official.transcriptTitle"/>
									<dict:fieldRef bean="course.official.catalogTitle"/>
									<dict:fieldRef bean="course.official.level"/>
									<dict:fieldRef bean="course.official.subjectArea"/>
									<dict:fieldRef bean="course.official.numberPart"/>
									<dict:fieldRef bean="course.official.version"/>
									<dict:fieldRef bean="course.official.adminOrg"/>
									<dict:fieldRef bean="course.official.type"/>
									<dict:fieldRef bean="course.official.state"/>
									<dict:fieldRef bean="course.official.internalId"/>
								</dict:state>
								<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<dict:fieldRef bean="course.official.no"/>
									<dict:fieldRef bean="course.official.transcriptTitle"/>
									<dict:fieldRef bean="course.official.catalogTitle"/>
									<dict:fieldRef bean="course.official.level"/>
									<dict:fieldRef bean="course.official.subjectArea"/>
									<dict:fieldRef bean="course.official.numberPart"/>
									<dict:fieldRef bean="course.official.version"/>
									<dict:fieldRef bean="course.official.adminOrg"/>
									<dict:fieldRef bean="course.official.type"/>
									<dict:fieldRef bean="course.official.state"/>
									<dict:fieldRef bean="course.official.internalId"/>
								</dict:state>
							</dict:type>
							<dict:type key="kuali.lu.type.CreditCourse.identifier.cross-listed">
								<!--
									This identifier holds the cross-listed identifiers for this
									course
								-->
								<!-- (MIT's meaning of joint) -->
								<dict:state key="active">
									<!-- Identifier is active -->
									<!--
										TODO: Worry about states overlapping across xmlObjects. The
										lookup on thge Dictionary worksheet will grab the wrong one
									-->
								</dict:state>
								<dict:state key="inactive">
									<!-- Identifier is inactive -->
								</dict:state>
							</dict:type>
							<dict:type key="kuali.lu.type.CreditCourse.identifier.version">
								<!--
									This identifier holds the version information for courses that
									have multiple versions
								-->
								<!-- Variation -->
								<dict:state key="active">
									<!-- Identifier is active -->
									<!--
										TODO: Worry about states overlapping across xmlObjects. The
										lookup on thge Dictionary worksheet will grab the wrong one
									-->
								</dict:state>
								<dict:state key="inactive">
									<!-- Identifier is inactive -->
								</dict:state>
							</dict:type>
						</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.alternateIdentifiers.draft" key="alternateIdentifiers">
					<dict:fieldDescriptor>
						<dict:name>course.alternateIdentifiers</dict:name>
						<dict:desc>course alternate ids</dict:desc>
						<dict:dataType>complex</dict:dataType>

						<dict:objectStructure key="cluIdentifierInfo">
							<!--
								Detailed information about the human readable form of a CLU
								Identifier
							-->
							<dict:type key="kuali.lu.type.CreditCourse.identifier.official">
								<!-- This identifier holds the official identifier for this course -->
								<dict:state key="active">
									<!-- Identifier is active -->
									<!--
										TODO: Worry about states overlapping across xmlObjects. The
										lookup on thge Dictionary worksheet will grab the wrong one
									-->
								</dict:state>
								<dict:state key="inactive">
									<!-- Identifier is inactive -->
								</dict:state>
							</dict:type>
							<dict:type key="kuali.lu.type.CreditCourse.identifier.cross-listed">
								<!--
									This identifier holds the cross-listed identifiers for this
									course
								-->
								<!-- (MIT's meaning of joint) -->
								<dict:state key="active">
									<!-- Identifier is active -->
									<!--
										TODO: Worry about states overlapping across xmlObjects. The
										lookup on thge Dictionary worksheet will grab the wrong one
									-->
									<dict:fieldRef bean="course.cross-listed.no"/>
									<dict:fieldRef bean="course.cross-listed.transcriptTitle"/>
									<dict:fieldRef bean="course.cross-listed.catalogTitle"/>
									<dict:fieldRef bean="course.cross-listed.level"/>
									<dict:fieldRef bean="course.cross-listed.subjectArea"/>
									<dict:fieldRef bean="course.cross-listed.numberPart"/>
									<dict:fieldRef bean="course.cross-listed.version"/>
									<dict:fieldRef bean="course.cross-listed.adminOrg"/>
									<dict:fieldRef bean="course.cross-listed.type"/>
									<dict:fieldRef bean="course.cross-listed.state"/>
									<dict:fieldRef bean="course.cross-listed.internalId"/>
								</dict:state>
								<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<dict:fieldRef bean="course.cross-listed.no"/>
									<dict:fieldRef bean="course.cross-listed.transcriptTitle"/>
									<dict:fieldRef bean="course.cross-listed.catalogTitle"/>
									<dict:fieldRef bean="course.cross-listed.level"/>
									<dict:fieldRef bean="course.cross-listed.subjectArea"/>
									<dict:fieldRef bean="course.cross-listed.numberPart"/>
									<dict:fieldRef bean="course.cross-listed.version"/>
									<dict:fieldRef bean="course.cross-listed.adminOrg"/>
									<dict:fieldRef bean="course.cross-listed.type"/>
									<dict:fieldRef bean="course.cross-listed.state"/>
									<dict:fieldRef bean="course.cross-listed.internalId"/>
								</dict:state>
							</dict:type>
							<dict:type key="kuali.lu.type.CreditCourse.identifier.version">
								<!--
									This identifier holds the version information for courses that
									have multiple versions
								-->
								<!-- Variation -->
								<dict:state key="active">
									<!-- Identifier is active -->
									<!--
										TODO: Worry about states overlapping across xmlObjects. The
										lookup on thge Dictionary worksheet will grab the wrong one
									-->
									<dict:fieldRef bean="course.version.no"/>
									<dict:fieldRef bean="course.version.transcriptTitle"/>
									<dict:fieldRef bean="course.version.catalogTitle"/>
									<dict:fieldRef bean="course.version.level"/>
									<dict:fieldRef bean="course.version.subjectArea"/>
									<dict:fieldRef bean="course.version.numberPart"/>
									<dict:fieldRef bean="course.version.version"/>
									<dict:fieldRef bean="course.version.adminOrg"/>
									<dict:fieldRef bean="course.version.type"/>
									<dict:fieldRef bean="course.version.state"/>
									<dict:fieldRef bean="course.version.internalId"/>
								</dict:state>
								<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<dict:fieldRef bean="course.version.no"/>
									<dict:fieldRef bean="course.version.transcriptTitle"/>
									<dict:fieldRef bean="course.version.catalogTitle"/>
									<dict:fieldRef bean="course.version.level"/>
									<dict:fieldRef bean="course.version.subjectArea"/>
									<dict:fieldRef bean="course.version.numberPart"/>
									<dict:fieldRef bean="course.version.version"/>
									<dict:fieldRef bean="course.version.adminOrg"/>
									<dict:fieldRef bean="course.version.type"/>
									<dict:fieldRef bean="course.version.state"/>
									<dict:fieldRef bean="course.version.internalId"/>
								</dict:state>
							</dict:type>
						</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="repeating"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.campusLocation.draft" key="campusLocationInfo">
					<!--
						The message structure goes to another substructure but that just
						holds a string so I don't thnk that is needed and I changed the
						name to "Info" instead of "List" which is on the un-needed
						sub-structure
					-->
					<dict:fieldDescriptor>
						<dict:name>course.campusLocation</dict:name>
						<dict:desc>campus location</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="repeating"/>
						<dict:constraintRef bean="code"/>
						<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.desc.draft" key="desc">
					<dict:fieldDescriptor>
						<dict:name>course.desc</dict:name>
						<dict:desc>dscription</dict:desc>
						<dict:dataType>complex</dict:dataType>

						<dict:objectStructure key="richTextInfo">
							<!--
								Complex type supporting both a plain text and formatted version
								of a string.
							-->
							<dict:type key="(n/a)">
								<!-- Not applicable -->
								<dict:state key="(n/a)">
									<!-- Not applicable -->
								</dict:state>
							</dict:type>
						</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.rationale.draft" key="marketingDesc">
					<!--
						Not used in KRU but wanted an example of multiple RichText fields
					-->
					<dict:fieldDescriptor>
						<dict:name>course.rationale</dict:name>
						<dict:desc>rationale</dict:desc>
						<dict:dataType>complex</dict:dataType>

						<dict:objectStructure key="richTextInfo">
							<!--
								Complex type supporting both a plain text and formatted version
								of a string.
							-->
							<dict:type key="(n/a)">
								<!-- Not applicable -->
								<dict:state key="(n/a)">
									<!-- Not applicable -->
								</dict:state>
							</dict:type>
						</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.primaryAdminOrg.draft" key="primaryAdminOrg">
					<!--
						Services has this on it's own structure called AdminOrgInfo that
						allows for dynamic fields to be attached to the org but I am not
						modeling that right now so I don't have to go to 3 levels.
					-->
					<dict:fieldDescriptor>
						<dict:name>course.primaryAdminOrg</dict:name>
						<dict:desc>department</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="related.orgId"/>
						<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>

				<dict:field id="course.alternateAdminOrgs.draft" key="alternateAdminOrgs">
					<!--
						Services has this on it's own structure called AdminOrgInfo that
						allows for dynamic fields to be attached to the org but I am not
						modeling that right now so I don't have to go to 3 levels.
					-->
					<dict:fieldDescriptor>
						<dict:name>course.alternateAdminOrgs</dict:name>
						<dict:desc>not used</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="repeating"/>
						<dict:constraintRef bean="related.orgId"/>
						<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.effectiveDate.draft" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>course.effectiveDate</dict:name>
						<dict:desc>first date can be offered</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="date"/>
						<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.expirationDate.draft" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>course.expirationDate</dict:name>
						<dict:desc>last date can be offerred</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="date"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.contact.hours.draft" key="intensity">
					<dict:fieldDescriptor>
						<dict:name>course.contact.hours</dict:name>
						<dict:desc>contact hours</dict:desc>
						<dict:dataType>complex</dict:dataType>

						<dict:objectStructure key="amountInfo">
							<!--
								Detailed information about an amount including both the type of
								units and the quantity.
							-->
							<dict:type key="(n/a)">
								<!-- Not applicable -->
								<dict:state key="(n/a)">
									<!-- Not applicable -->
								</dict:state>
							</dict:type>
						</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.duration.draft" key="stdDuration">
					<dict:fieldDescriptor>
						<dict:name>course.duration</dict:name>
						<dict:desc>duration</dict:desc>
						<dict:dataType>complex</dict:dataType>

						<dict:objectStructure key="timeAmountInfo">
							<!--
								Detailed information about an amount of time including both the
								type of units and the quantity.
							-->
							<dict:type key="(n/a)">
								<!-- Not applicable -->
								<dict:state key="(n/a)">
									<!-- Not applicable -->
								</dict:state>
							</dict:type>
						</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.seasons.draft" key="offeredAtpTypes">
					<!--
						Services has this as an atpKeyList but that is just a list of
						Strings so I didn't create the sub-structure
					-->
					<dict:fieldDescriptor>
						<dict:name>course.seasons</dict:name>
						<dict:desc>seasons offered</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="repeating"/>
						<dict:constraintRef bean="atp.types"/>
						<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.dynamic.attributes.draft" key="attributes">
					<!--
						Services has this as an attributeInfoList but that is just a list
						of the attributeInfo substructure so I did't create the
						intermediary list sub-structure
					-->
					<dict:fieldDescriptor>
						<dict:name>course.dynamic.attributes</dict:name>
						<dict:desc>not used</dict:desc>
						<dict:dataType>complex</dict:dataType>

						<dict:objectStructure key="attributeInfo">
							<!-- List of key/value pairs, typically used for dynamic attributes. -->
							<dict:type key="(n/a)">
								<!-- Not applicable -->
								<dict:state key="(n/a)">
									<!-- Not applicable -->
								</dict:state>
							</dict:type>
						</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="repeating"/>
						<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.meta.draft" key="metaInfo">
					<!-- must be empty on create but required on update -->
					<dict:fieldDescriptor>
						<dict:name>course.meta</dict:name>
						<dict:desc>audit trail info</dict:desc>
						<dict:dataType>complex</dict:dataType>

						<dict:objectStructure key="metaInfo">
							<!--
								Create and last update info for the structure. This is optional
								and treated as read only since the data is set by the internals
								of the service during maintenance operations.
							-->
							<dict:type key="(n/a)">
								<!-- Not applicable -->
								<dict:state key="(n/a)">
									<!-- Not applicable -->
								</dict:state>
							</dict:type>
						</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="kuali.meta.data"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.type.draft" key="type">
					<!-- Requierd on the create but read-only after that -->
					<dict:fieldDescriptor>
						<dict:name>course.type</dict:name>
						<dict:desc>type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="kuali.type"/>
						<dict:constraintRef bean="lu.types"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.state.draft" key="state">
					<dict:fieldDescriptor>
						<dict:name>course.state</dict:name>
						<dict:desc>state</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="kuali.state"/>
						<dict:constraintRef bean="lu.states"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>

				<dict:field id="course.internalId.draft" key="id">
					<!-- must be empty on create but required on update -->
					<dict:fieldDescriptor>
						<dict:name>course.internalId</dict:name>
						<dict:desc>internal id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="kuali.id"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="submitted">
				<!-- Submitted but not yet approved -->
				<dict:fieldRef bean="course.no"/>
				<dict:fieldRef bean="course.alternateIdentifiers"/>
				<dict:fieldRef bean="course.campusLocation"/>
				<dict:fieldRef bean="course.desc"/>
				<dict:fieldRef bean="course.rationale"/>
				<dict:fieldRef bean="course.primaryAdminOrg"/>
				<dict:fieldRef bean="course.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.effectiveDate"/>
				<dict:fieldRef bean="course.expirationDate"/>
				<dict:fieldRef bean="course.contact.hours"/>
				<dict:fieldRef bean="course.duration"/>
				<dict:fieldRef bean="course.seasons"/>
				<dict:fieldRef bean="course.dynamic.attributes"/>
				<dict:fieldRef bean="course.meta"/>
				<dict:fieldRef bean="course.type"/>
				<dict:fieldRef bean="course.state"/>
				<dict:fieldRef bean="course.internalId"/>
			</dict:state>
			<dict:state key="withdrawn">
				<!-- Withdrawn (anytime before activated) -->
				<dict:fieldRef bean="course.no"/>
				<dict:fieldRef bean="course.alternateIdentifiers"/>
				<dict:fieldRef bean="course.campusLocation"/>
				<dict:fieldRef bean="course.desc"/>
				<dict:fieldRef bean="course.rationale"/>
				<dict:fieldRef bean="course.primaryAdminOrg"/>
				<dict:fieldRef bean="course.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.effectiveDate"/>
				<dict:fieldRef bean="course.expirationDate"/>
				<dict:fieldRef bean="course.contact.hours"/>
				<dict:fieldRef bean="course.duration"/>
				<dict:fieldRef bean="course.seasons"/>
				<dict:fieldRef bean="course.dynamic.attributes"/>
				<dict:fieldRef bean="course.meta"/>
				<dict:fieldRef bean="course.type"/>
				<dict:fieldRef bean="course.state"/>
				<dict:fieldRef bean="course.internalId"/>
			</dict:state>
			<dict:state key="approved">
				<!-- Approved -->
				<dict:fieldRef bean="course.no"/>
				<dict:fieldRef bean="course.alternateIdentifiers"/>
				<dict:fieldRef bean="course.campusLocation"/>
				<dict:fieldRef bean="course.desc"/>
				<dict:fieldRef bean="course.rationale"/>
				<dict:fieldRef bean="course.primaryAdminOrg"/>
				<dict:fieldRef bean="course.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.effectiveDate"/>
				<dict:fieldRef bean="course.expirationDate"/>
				<dict:fieldRef bean="course.contact.hours"/>
				<dict:fieldRef bean="course.duration"/>
				<dict:fieldRef bean="course.seasons"/>
				<dict:fieldRef bean="course.dynamic.attributes"/>
				<dict:fieldRef bean="course.meta"/>
				<dict:fieldRef bean="course.type"/>
				<dict:fieldRef bean="course.state"/>
				<dict:fieldRef bean="course.internalId"/>
			</dict:state>
			<dict:state key="not">
				<!-- Not approved -->
				<!--
					Do we need here some indication of why it was not approved? I.e.
					disapproved vs. not acted on because submitted too late, etc.
				-->
				<dict:fieldRef bean="course.no"/>
				<dict:fieldRef bean="course.alternateIdentifiers"/>
				<dict:fieldRef bean="course.campusLocation"/>
				<dict:fieldRef bean="course.desc"/>
				<dict:fieldRef bean="course.rationale"/>
				<dict:fieldRef bean="course.primaryAdminOrg"/>
				<dict:fieldRef bean="course.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.effectiveDate"/>
				<dict:fieldRef bean="course.expirationDate"/>
				<dict:fieldRef bean="course.contact.hours"/>
				<dict:fieldRef bean="course.duration"/>
				<dict:fieldRef bean="course.seasons"/>
				<dict:fieldRef bean="course.dynamic.attributes"/>
				<dict:fieldRef bean="course.meta"/>
				<dict:fieldRef bean="course.type"/>
				<dict:fieldRef bean="course.state"/>
				<dict:fieldRef bean="course.internalId"/>
			</dict:state>
			<dict:state key="activated">
				<!-- Activated and ready to be published -->
				<dict:fieldRef bean="course.no"/>
				<dict:fieldRef bean="course.alternateIdentifiers"/>
				<dict:fieldRef bean="course.campusLocation"/>
				<dict:fieldRef bean="course.desc"/>
				<dict:fieldRef bean="course.rationale"/>
				<dict:fieldRef bean="course.primaryAdminOrg"/>
				<dict:fieldRef bean="course.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.effectiveDate"/>
				<dict:fieldRef bean="course.expirationDate"/>
				<dict:fieldRef bean="course.contact.hours"/>
				<dict:fieldRef bean="course.duration"/>
				<dict:fieldRef bean="course.seasons"/>
				<dict:fieldRef bean="course.dynamic.attributes"/>
				<dict:fieldRef bean="course.meta"/>
				<dict:fieldRef bean="course.type"/>
				<dict:fieldRef bean="course.state"/>
				<dict:fieldRef bean="course.internalId"/>
			</dict:state>
			<dict:state key="retired">
				<!-- Retired/No longer active -->
				<!--
					Do we need/want to differentiate here between retiring a course
					simply because it will no longer be taught and retiring a version
					of a course because it has been superceded by a newer version.
				-->
				<dict:fieldRef bean="course.no"/>
				<dict:fieldRef bean="course.alternateIdentifiers"/>
				<dict:fieldRef bean="course.campusLocation"/>
				<dict:fieldRef bean="course.desc"/>
				<dict:fieldRef bean="course.rationale"/>
				<dict:fieldRef bean="course.primaryAdminOrg"/>
				<dict:fieldRef bean="course.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.effectiveDate"/>
				<dict:fieldRef bean="course.expirationDate"/>
				<dict:fieldRef bean="course.contact.hours"/>
				<dict:fieldRef bean="course.duration"/>
				<dict:fieldRef bean="course.seasons"/>
				<dict:fieldRef bean="course.dynamic.attributes"/>
				<dict:fieldRef bean="course.meta"/>
				<dict:fieldRef bean="course.type"/>
				<dict:fieldRef bean="course.state"/>
				<dict:fieldRef bean="course.internalId"/>
			</dict:state>
		</dict:type>
	</dict:objectStructure>
</beans>
